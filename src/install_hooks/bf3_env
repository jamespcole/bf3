b:b () 
{ 
    "${BF3_bml_VARS[output]}".bold "$@"
}
b:box () 
{ 
    "${BF3_bml_VARS[output]}".box "$@"
}
b:br () 
{ 
    "${BF3_bml_VARS[output]}".br "$@"
}
b:d () 
{ 
    "${BF3_bml_VARS[output]}".dim "$@"
}
b:danger () 
{ 
    "${BF3_bml_VARS[output]}".danger "$@"
}
b:em () 
{ 
    "${BF3_bml_VARS[output]}".emphasis "$@"
}
b:figlet () 
{ 
    "${BF3_bml_VARS[output]}".figlet "$@"
}
b:fmt () 
{ 
    "${BF3_bml_VARS[output]}".fmt "$@"
}
b:graphviz-dot () 
{ 
    "${BF3_bml_VARS[output]}".graphviz-dot "$@"
}
b:h1 () 
{ 
    "${BF3_bml_VARS[output]}".heading1 "$@"
}
b:h2 () 
{ 
    "${BF3_bml_VARS[output]}".heading2 "$@"
}
b:h3 () 
{ 
    "${BF3_bml_VARS[output]}".heading3 "$@"
}
b:h4 () 
{ 
    "${BF3_bml_VARS[output]}".heading4 "$@"
}
b:h5 () 
{ 
    "${BF3_bml_VARS[output]}".heading5 "$@"
}
b:h6 () 
{ 
    "${BF3_bml_VARS[output]}".heading6 "$@"
}
b:horiz () 
{ 
    "${BF3_bml_VARS[output]}".horiz "$@"
}
b:hr () 
{ 
    "${BF3_bml_VARS[output]}".hr "$@"
}
b:icon () 
{ 
    "${BF3_bml_VARS[output]}".icon "$@"
}
b:in () 
{ 
    "${BF3_bml_VARS[output]}".indent "$@"
}
b:info () 
{ 
    "${BF3_bml_VARS[output]}".info "$@"
}
b:li () 
{ 
    "${BF3_bml_VARS[output]}".listItem "$@"
}
b:list () 
{ 
    "${BF3_bml_VARS[output]}".list "$@"
}
b:success () 
{ 
    "${BF3_bml_VARS[output]}".success "$@"
}
b:u () 
{ 
    "${BF3_bml_VARS[output]}".underline "$@"
}
b:warning () 
{ 
    "${BF3_bml_VARS[output]}".warning "$@"
}
bf3.cmd.bootstrap.build () 
{ 
    local cmdNameSpace="$1";
    shift;
    local buildStartMs=$(date +%s%3N);
    local installDir="${BF3_ACTIVE_PATH}/install_hooks";
    mkdir -p "${installDir}";
    local outputFile="${installDir}/${globals['commandName']}";
    echo "Beginning transpilation...";
    import.require "${cmdNameSpace}";
    echo "Writing transpiled functions...";
    declare -f > "${outputFile}";
    echo "Adding dependency list...";
    declare -p __import_DEPENDENCIES >> "${outputFile}";
    import.require 'build';
    import.useModule 'build';
    echo "Adding command init functions...";
    build.getInitFunctions >> "${outputFile}";
    echo "Running precacheable functions...";
    import.useModules;
    if import.functionExists "${cmdNameSpace}.main::args"; then
        "${cmdNameSpace}.main::args";
    fi;
    local funcName;
    while read funcName; do
        echo "Precaching '${funcName}'...";
        "${funcName}" > /dev/null;
        echo "Adding the '${funcName}::cached' function to the build...";
        declare -f "${funcName}::cached" >> "${outputFile}";
    done < <( declare -F | grep '::precache$' | sed 's/^declare -f //' | sed 's/::precache$//');
    echo "Adding command execution functions...";
    echo 'import.useModules' >> "${outputFile}";
    echo 'globals[built]=true' >> "${outputFile}";
    echo "globals[commandNamespace]='${cmdNameSpace}'" >> "${outputFile}";
    echo "globals[commandName]='${globals[commandName]}'" >> "${outputFile}";
    echo "globals[buildDate]='$(date '+%Y-%m-%d %H:%M:%S')'" >> "${outputFile}";
    echo 'cmd.run.loadArgs "$@"' >> "${outputFile}";
    chmod +x "${outputFile}";
    local msTotal=$(($(date +%s%3N)-$buildStartMs));
    local timeStr="${msTotal}ms";
    if [ $msTotal -gt 1000 ]; then
        local seconds="$(($msTotal/1000))";
        local roundedMs=$(($seconds*1000));
        local remainderMs=$(($msTotal-$roundedMs));
        timeStr="${seconds}.${remainderMs} seconds";
    fi;
    echo "";
    echo "Writing compiled source to '${outputFile}'.";
    echo "Command '${globals[commandName]}' built successfuly in ${timeStr}.";
    echo "You now execute the command by running: ${globals[commandName]}"
}
bf3.cmd.bootstrap.init () 
{ 
    import.useModules;
    logger.args;
    function bf3.cmd.bootstrap.run () 
    { 
        local cmdNameSpace="$1";
        shift;
        logger.processStartupArgs;
        globals[built]=false;
        globals[commandNamespace]="${cmdNameSpace}";
        globals[buildDate]="$(date '+%Y-%m-%d %H:%M:%S')";
        if import.functionExists "${cmdNameSpace}.main::args"; then
            "${cmdNameSpace}.main::args";
        fi;
        local -A params;
        local -a unknown;
        parameters.load --namespace 'global' --ignore-unknown true --args "$@";
        for paramValKey in "${!params[@]}";
        do
            globals["${paramValKey}"]="${params[${paramValKey}]}";
        done;
        "${cmdNameSpace}.main" "${unknown[@]}"
    };
    function bf3.cmd.bootstrap.build () 
    { 
        local cmdNameSpace="$1";
        shift;
        local buildStartMs=$(date +%s%3N);
        local installDir="${BF3_ACTIVE_PATH}/install_hooks";
        mkdir -p "${installDir}";
        local outputFile="${installDir}/${globals['commandName']}";
        echo "Beginning transpilation...";
        import.require "${cmdNameSpace}";
        echo "Writing transpiled functions...";
        declare -f > "${outputFile}";
        echo "Adding dependency list...";
        declare -p __import_DEPENDENCIES >> "${outputFile}";
        import.require 'build';
        import.useModule 'build';
        echo "Adding command init functions...";
        build.getInitFunctions >> "${outputFile}";
        echo "Running precacheable functions...";
        import.useModules;
        if import.functionExists "${cmdNameSpace}.main::args"; then
            "${cmdNameSpace}.main::args";
        fi;
        local funcName;
        while read funcName; do
            echo "Precaching '${funcName}'...";
            "${funcName}" > /dev/null;
            echo "Adding the '${funcName}::cached' function to the build...";
            declare -f "${funcName}::cached" >> "${outputFile}";
        done < <( declare -F | grep '::precache$' | sed 's/^declare -f //' | sed 's/::precache$//');
        echo "Adding command execution functions...";
        echo 'import.useModules' >> "${outputFile}";
        echo 'globals[built]=true' >> "${outputFile}";
        echo "globals[commandNamespace]='${cmdNameSpace}'" >> "${outputFile}";
        echo "globals[commandName]='${globals[commandName]}'" >> "${outputFile}";
        echo "globals[buildDate]='$(date '+%Y-%m-%d %H:%M:%S')'" >> "${outputFile}";
        echo 'cmd.run.loadArgs "$@"' >> "${outputFile}";
        chmod +x "${outputFile}";
        local msTotal=$(($(date +%s%3N)-$buildStartMs));
        local timeStr="${msTotal}ms";
        if [ $msTotal -gt 1000 ]; then
            local seconds="$(($msTotal/1000))";
            local roundedMs=$(($seconds*1000));
            local remainderMs=$(($msTotal-$roundedMs));
            timeStr="${seconds}.${remainderMs} seconds";
        fi;
        echo "";
        echo "Writing compiled source to '${outputFile}'.";
        echo "Command '${globals[commandName]}' built successfuly in ${timeStr}.";
        echo "You now execute the command by running: ${globals[commandName]}"
    }
}
bf3.cmd.bootstrap.run () 
{ 
    local cmdNameSpace="$1";
    shift;
    logger.processStartupArgs;
    globals[built]=false;
    globals[commandNamespace]="${cmdNameSpace}";
    globals[buildDate]="$(date '+%Y-%m-%d %H:%M:%S')";
    if import.functionExists "${cmdNameSpace}.main::args"; then
        "${cmdNameSpace}.main::args";
    fi;
    local -A params;
    local -a unknown;
    parameters.load --namespace 'global' --ignore-unknown true --args "$@";
    for paramValKey in "${!params[@]}";
    do
        globals["${paramValKey}"]="${params[${paramValKey}]}";
    done;
    "${cmdNameSpace}.main" "${unknown[@]}"
}
bf3.cmd.build () 
{ 
    bf3.cmd.bootstrap.build "$@"
}
bf3.cmd.run () 
{ 
    bf3.cmd.bootstrap.run "$@"
}
bf3.run.module () 
{ 
    parameters.add --key 'run' --namespace 'run' --name 'Module' --alias '-r' --alias '--run' --desc 'The name of the module to run.' --required-unless 'run::build' --excludes 'run::build' --excludes 'run::buildName' --has-value 'y';
    parameters.add --key 'build' --namespace 'run' --name 'Build' --alias '-b' --alias '--build' --desc 'Build into a single distributable command.' --required-unless 'run::run' --excludes 'run::run' --inlcudes 'run::build' --has-value 'y';
    parameters.add --key 'buildName' --namespace 'run' --name 'Build Name' --alias '--build-name' --desc 'The name of the command when built.' --required-unless 'run::run' --has-value 'y';
    local -A params;
    local -a unknown;
    parameters.load --namespace 'run' --ignore-unknown true --args "${@}";
    globals['isBuilding']=false;
    if [ "${params[run>>specified]}" == '1' ]; then
        globals['commandNamespace']="${params['run']}";
        globals['commandName']="${params['run']}";
        logger.processStartupArgs;
        logger.warning --message "You are running this module using runtime transpilation.";
        logger.warning --message "This is useful during development but has significantly reduced performance.";
        logger.warning --message "To compile this command run:";
        logger.warning --message "    bf3 --build '${params['run']}' --build-name 'my-command'";
        logger.hr;
        logger.info --message "Transpiling command...";
        local basetime=$(date +%s%3N);
        import.require "${params['run']}";
        local msTotal=$(($(date +%s%3N)-$basetime));
        local timeStr="${msTotal}ms";
        if [ $msTotal -gt 1000 ]; then
            local seconds="$(($msTotal/1000))";
            local roundedMs=$(($seconds*1000));
            local remainderMs=$(($msTotal-$roundedMs));
            timeStr="${seconds}.${remainderMs} seconds";
        fi;
        logger.info --message "Transpiled ${#__import_DEPENDENCIES[@]} modules in: ${timeStr}";
        logger.hr;
        import.useModules;
        bf3.cmd.run "${params['run']}" "${unknown[@]}";
    else
        globals['isBuilding']=true;
        globals['commandNamespace']="${params['build']}";
        globals['commandName']="${params['build']}";
        logger.processStartupArgs;
        if [ "${params['buildName>>specified']}" ]; then
            globals['commandName']="${params['buildName']}";
        fi;
        bf3.cmd.build "${params['build']}" "${unknown[@]}";
    fi
}
bml.init () 
{ 
    if [ -z $BF3_bml_VARS_REAL ]; then
        declare -A -g BF3_bml_VARS_REAL;
        declare -g -n BF3_bml_VARS=BF3_bml_VARS_REAL;
    fi;
    BF3_bml_VARS[namespace]='bml';
    BF3_bml_VARS[output]='bml.shell';
    function b:u () 
    { 
        "${BF3_bml_VARS[output]}".underline "$@"
    };
    function b:b () 
    { 
        "${BF3_bml_VARS[output]}".bold "$@"
    };
    function b:d () 
    { 
        "${BF3_bml_VARS[output]}".dim "$@"
    };
    function b:list () 
    { 
        "${BF3_bml_VARS[output]}".list "$@"
    };
    function b:li () 
    { 
        "${BF3_bml_VARS[output]}".listItem "$@"
    };
    function b:in () 
    { 
        "${BF3_bml_VARS[output]}".indent "$@"
    };
    function b:h1 () 
    { 
        "${BF3_bml_VARS[output]}".heading1 "$@"
    };
    function b:h2 () 
    { 
        "${BF3_bml_VARS[output]}".heading2 "$@"
    };
    function b:h3 () 
    { 
        "${BF3_bml_VARS[output]}".heading3 "$@"
    };
    function b:h4 () 
    { 
        "${BF3_bml_VARS[output]}".heading4 "$@"
    };
    function b:h5 () 
    { 
        "${BF3_bml_VARS[output]}".heading5 "$@"
    };
    function b:h6 () 
    { 
        "${BF3_bml_VARS[output]}".heading6 "$@"
    };
    function b:hr () 
    { 
        "${BF3_bml_VARS[output]}".hr "$@"
    };
    function b:box () 
    { 
        "${BF3_bml_VARS[output]}".box "$@"
    };
    function b:fmt () 
    { 
        "${BF3_bml_VARS[output]}".fmt "$@"
    };
    function b:horiz () 
    { 
        "${BF3_bml_VARS[output]}".horiz "$@"
    };
    function b:br () 
    { 
        "${BF3_bml_VARS[output]}".br "$@"
    };
    function b:em () 
    { 
        "${BF3_bml_VARS[output]}".emphasis "$@"
    };
    function b:success () 
    { 
        "${BF3_bml_VARS[output]}".success "$@"
    };
    function b:danger () 
    { 
        "${BF3_bml_VARS[output]}".danger "$@"
    };
    function b:info () 
    { 
        "${BF3_bml_VARS[output]}".info "$@"
    };
    function b:warning () 
    { 
        "${BF3_bml_VARS[output]}".warning "$@"
    };
    function b:icon () 
    { 
        "${BF3_bml_VARS[output]}".icon "$@"
    };
    function b:figlet () 
    { 
        "${BF3_bml_VARS[output]}".figlet "$@"
    };
    function b:graphviz-dot () 
    { 
        "${BF3_bml_VARS[output]}".graphviz-dot "$@"
    };
    function bml.main::args () 
    { 
        parameters.add --key 'inputFile' --namespace 'bml.main' --name 'Input File' --alias '--input-file' --alias '-i' --desc 'The path to a bml file to parse' --required-unless 'bml.main::example' --excludes 'bml.main::example' --has-value 'y' --type 'file_exists';
        parameters.add --key 'example' --namespace 'bml.main' --name 'Show BML Example' --alias '--example' --desc 'Shows some examples of how to use BML and what the output will look like.' --required-unless 'bml.main::inputFile' --excludes 'bml.main::inputFile' --has-value 'm' --default 'simple' --enum-value 'simple' --type 'enum';
        parameters.add --key 'margin' --namespace 'bml.main' --name 'Add a margin' --alias '--margin' --alias '-m' --desc 'Adds a left margin to all output.  The default is 2 space.' + '  Is used when using "TERM" as the output format.' --has-value 'm' --default '  ';
        parameters.add --key 'format' --namespace 'bml.main' --name 'Output Format' --alias '--format' --alias '-F' --desc 'The output format to use, at the moment terminal "TERM"(default)' + ' and markdown "MD" and "RAW" are supported.' --required '0' --has-value 'y' --enum-value 'TERM' --enum-value 'MD' --enum-value 'RAW' --default 'TERM' --type 'enum';
        parameters.add --key 'outputFile' --namespace 'bml.main' --name 'Output File' --alias '--out-file' --alias '-o' --desc 'The path of a file to write the generated document to.' --required '0' --has-value 'y';
        parameters.add --key 'clearOutput' --namespace 'bml.main' --name 'Clear Screen' --alias '--clear' --alias '-c' --desc 'If passed this will clear the terminal before printing.' --required '0' --has-value 'n'
    };
    function bml.main () 
    { 
        "bml.${FUNCNAME[0]##*.}::args";
        local -A params;
        parameters.load --namespace "bml.${FUNCNAME[0]##*.}" --args "$@";
        if [ ${params['format']} == 'MD' ]; then
            BF3_bml_VARS[output]='bml.markdown';
        fi;
        if [ ${params['format']} != 'TERM' ]; then
            params['margin']='';
        fi;
        if [ "${params['clearOutput>>specified']}" == '1' ] && [ "${params['format']}" == 'TERM' ]; then
            clear;
            clear;
        fi;
        local raw;
        if [ "${params['example>>specified']}" == '1' ]; then
            raw=$(bml.printExample);
        else
            raw="$(cat ${params['inputFile']})";
        fi;
        local processed;
        if [ "${params['format']}" == 'RAW' ]; then
            processed="$raw";
        else
            processed=$(bml.printFile             --text "$raw"             --margin "${params['margin']}");
        fi;
        if [ "${params['outputFile>>specified']}" == '1' ]; then
            echo "${processed}" > "${params['outputFile']}";
        else
            echo "${processed}";
        fi
    };
    function bml.printExample () 
    { 
        echo "$(bml.resource.get 'docs/example.bml')"
    };
    function bml.printFile::args () 
    { 
        parameters.add --key 'text' --namespace 'bml.printFile' --name 'Raw BML Text' --alias '--text' --desc 'The raw BML text to process.' --required '1' --has-value 'y';
        parameters.add --key 'margin' --namespace 'bml.printFile' --name 'Add a margin' --alias '--margin' --alias '-m' --desc 'Adds a left margin to all output.  The default is 2 space.' + '  Is used when using "TERM" as the output format.' --has-value 'm' --default '  '
    };
    function bml.printFile () 
    { 
        "bml.${FUNCNAME[0]##*.}::args";
        local -A params;
        local -a unknown;
        parameters.load --namespace "bml.${FUNCNAME[0]##*.}" --ignore-unkown true --args "$@";
        bml.preProcess --text "${params['text']}" | sed "s/^/${params['margin']}&/"
    };
    function bml.print () 
    { 
        bml.preProcess "$@"
    };
    function bml.preProcess::args () 
    { 
        parameters.add --key 'text' --namespace 'bml.preProcess' --name 'Raw BML Text' --alias '--text' --desc 'The raw BML text to process.' --required '1' --has-value 'y'
    };
    function bml.preProcess () 
    { 
        "bml.${FUNCNAME[0]##*.}::args";
        local -A params;
        local -a unknown;
        parameters.load --namespace "bml.${FUNCNAME[0]##*.}" --ignore-unkown true --args "$@";
        local processedStr;
        processedStr=$(bml.printIteration1 "${params['text']}");
        processedStr=$(bml.printIteration2 "${processedStr}");
        processedStr=$(bml.printIteration3 "${processedStr}");
        echo -n "${processedStr}"
    };
    function bml.printIteration1 () 
    { 
        local outStr="$1";
        local startDelim='{{';
        local startTempDelim='{#{';
        local endDelim='}}';
        local endTempDelim='}#}';
        local startStepDelim='{<{';
        local endStepDelim='}<}';
        local startLiteralDelim='{!<{';
        local endLiteralDelim='}!<}';
        outStr="${outStr//$startDelim/$startTempDelim}";
        outStr="${outStr//$endDelim/$endTempDelim}";
        outStr="${outStr//$startStepDelim/$startDelim}";
        outStr="${outStr//$endStepDelim/$endDelim}";
        outStr=$("${BF3_bml_VARS[output]}".print --text "$outStr");
        outStr="${outStr//$startTempDelim/$startDelim}";
        outStr="${outStr//$endTempDelim/$endDelim}";
        outStr="${outStr//$startLiteralDelim/$startStepDelim}";
        outStr="${outStr//$endLiteralDelim/$endStepDelim}";
        echo -n "${outStr}"
    };
    function bml.printIteration2 () 
    { 
        local outStr="$1";
        local startDelim='{{';
        local endDelim='}}';
        local startStepDelim='{>{';
        local endStepDelim='}>}';
        local startLiteralDelim='{!>{';
        local endLiteralDelim='}!>}';
        outStr="${outStr//$startStepDelim/$startDelim}";
        outStr="${outStr//$endStepDelim/$endDelim}";
        outStr=$("${BF3_bml_VARS[output]}".print --text "$outStr");
        outStr="${outStr//$startLiteralDelim/$startStepDelim}";
        outStr="${outStr//$endLiteralDelim/$endStepDelim}";
        echo -n "${outStr}"
    };
    function bml.printIteration3 () 
    { 
        local outStr="$1";
        local startDelim='{{';
        local endDelim='}}';
        local startStepDelim='{!{';
        local endStepDelim='}!}';
        local startLiteralDelim='{!!{';
        local endLiteralDelim='}!!}';
        outStr="${outStr//$startStepDelim/$startDelim}";
        outStr="${outStr//$endStepDelim/$endDelim}";
        outStr="${outStr//$startLiteralDelim/$startStepDelim}";
        outStr="${outStr//$endLiteralDelim/$endStepDelim}";
        echo -n "${outStr}"
    };
    function bml.loadTheme () 
    { 
        "${BF3_bml_VARS[output]}".loadTheme "$@"
    }
}
bml.loadTheme () 
{ 
    "${BF3_bml_VARS[output]}".loadTheme "$@"
}
bml.main () 
{ 
    "bml.${FUNCNAME[0]##*.}::args";
    local -A params;
    parameters.load --namespace "bml.${FUNCNAME[0]##*.}" --args "$@";
    if [ ${params['format']} == 'MD' ]; then
        BF3_bml_VARS[output]='bml.markdown';
    fi;
    if [ ${params['format']} != 'TERM' ]; then
        params['margin']='';
    fi;
    if [ "${params['clearOutput>>specified']}" == '1' ] && [ "${params['format']}" == 'TERM' ]; then
        clear;
        clear;
    fi;
    local raw;
    if [ "${params['example>>specified']}" == '1' ]; then
        raw=$(bml.printExample);
    else
        raw="$(cat ${params['inputFile']})";
    fi;
    local processed;
    if [ "${params['format']}" == 'RAW' ]; then
        processed="$raw";
    else
        processed=$(bml.printFile             --text "$raw"             --margin "${params['margin']}");
    fi;
    if [ "${params['outputFile>>specified']}" == '1' ]; then
        echo "${processed}" > "${params['outputFile']}";
    else
        echo "${processed}";
    fi
}
bml.main::args () 
{ 
    parameters.add --key 'inputFile' --namespace 'bml.main' --name 'Input File' --alias '--input-file' --alias '-i' --desc 'The path to a bml file to parse' --required-unless 'bml.main::example' --excludes 'bml.main::example' --has-value 'y' --type 'file_exists';
    parameters.add --key 'example' --namespace 'bml.main' --name 'Show BML Example' --alias '--example' --desc 'Shows some examples of how to use BML and what the output will look like.' --required-unless 'bml.main::inputFile' --excludes 'bml.main::inputFile' --has-value 'm' --default 'simple' --enum-value 'simple' --type 'enum';
    parameters.add --key 'margin' --namespace 'bml.main' --name 'Add a margin' --alias '--margin' --alias '-m' --desc 'Adds a left margin to all output.  The default is 2 space.' + '  Is used when using "TERM" as the output format.' --has-value 'm' --default '  ';
    parameters.add --key 'format' --namespace 'bml.main' --name 'Output Format' --alias '--format' --alias '-F' --desc 'The output format to use, at the moment terminal "TERM"(default)' + ' and markdown "MD" and "RAW" are supported.' --required '0' --has-value 'y' --enum-value 'TERM' --enum-value 'MD' --enum-value 'RAW' --default 'TERM' --type 'enum';
    parameters.add --key 'outputFile' --namespace 'bml.main' --name 'Output File' --alias '--out-file' --alias '-o' --desc 'The path of a file to write the generated document to.' --required '0' --has-value 'y';
    parameters.add --key 'clearOutput' --namespace 'bml.main' --name 'Clear Screen' --alias '--clear' --alias '-c' --desc 'If passed this will clear the terminal before printing.' --required '0' --has-value 'n'
}
bml.markdown.__init () 
{ 
    bml.markdown.loadTheme
}
bml.markdown.blue () 
{ 
    echo "$1"
}
bml.markdown.bold () 
{ 
    bml.markdown.print --text "__${1}__"
}
bml.markdown.box () 
{ 
    echo "";
    echo "$1" | fmt -w 80 | sed 's/^/> /';
    echo ""
}
bml.markdown.br () 
{ 
    bml.markdown.printLine --text ""
}
bml.markdown.cyan () 
{ 
    echo "$1"
}
bml.markdown.danger () 
{ 
    echo "$1"
}
bml.markdown.dim () 
{ 
    echo "$1"
}
bml.markdown.emphasis () 
{ 
    bml.markdown.print --text "_${1}_"
}
bml.markdown.figlet () 
{ 
    provision.require 'figlet' > /dev/null || { 
        echo 'Provision dependency "figlet" is not available in textprint'
    };
    bml.markdown.printLine --text '```';
    figlet "$1";
    bml.markdown.printLine --text '```'
}
bml.markdown.fmt () 
{ 
    local __prev_state;
    bml.markdown.getState __prev_state;
    bml.markdown.setProp --prop 'remove_nl' --state 1;
    bml.markdown.setProp --prop 'remove_tab' --state 1;
    bml.markdown.print --text "$1";
    bml.markdown.restoreState "${__prev_state}"
}
bml.markdown.getState () 
{ 
    local __ret_var=$1;
    local __prev_state_data=$(declare -p BF3_bml_markdown_state);
    __prev_state_data=${__prev_state_data/-A/-A -g};
    string.return_value "$__prev_state_data" $__ret_var
}
bml.markdown.graphviz-dot () 
{ 
    provision.require 'visual.graphviz' > /dev/null || { 
        echo 'Provision dependency "visual.graphviz" is not available'
    };
    echo "![Diagram](data:image/jpeg;base64,$(dot -Tpng <(echo "$1") | base64 -w 0))"
}
bml.markdown.green () 
{ 
    echo "$1"
}
bml.markdown.heading1 () 
{ 
    bml.markdown.printLine --text "# ${1}";
    bml.markdown.printLine --text ""
}
bml.markdown.heading2 () 
{ 
    bml.markdown.printLine --text "## ${1}";
    bml.markdown.printLine --text ""
}
bml.markdown.heading3 () 
{ 
    bml.markdown.printLine --text "### ${1}";
    bml.markdown.printLine --text ""
}
bml.markdown.heading4 () 
{ 
    bml.markdown.printLine --text "#### ${1}";
    bml.markdown.printLine --text ""
}
bml.markdown.heading5 () 
{ 
    bml.markdown.printLine --text "##### ${1}";
    bml.markdown.printLine --text ""
}
bml.markdown.heading6 () 
{ 
    bml.markdown.printLine --text "###### ${1}";
    bml.markdown.printLine --text ""
}
bml.markdown.horiz () 
{ 
    local trimmedText;
    string.trim trimmedText "$1";
    local hText=${trimmedText//'
'/'	'};
    hText="$(echo "${hText}" | sed -e 's/	\+/	/g')";
    bml.markdown.print --text "${hText/	/}"
}
bml.markdown.hr () 
{ 
    bml.markdown.printLine --text '---'
}
bml.markdown.icon () 
{ 
    echo "$(echo -en ${BF3_bml_markdown_theme[${BF3_bml_markdown_VARS[themeId]}>>icon_$1]})"
}
bml.markdown.indent () 
{ 
    echo "$1" | sed 's/^/    &/'
}
bml.markdown.info () 
{ 
    echo "$1"
}
bml.markdown.init () 
{ 
    if [ -z $BF3_bml_markdown_VARS_REAL ]; then
        declare -A -g BF3_bml_markdown_VARS_REAL;
        declare -g -n BF3_bml_markdown_VARS=BF3_bml_markdown_VARS_REAL;
    fi;
    BF3_bml_markdown_VARS[namespace]='bml.markdown';
    [ -z $BF3_bml_markdown_state ] && declare -A -g BF3_bml_markdown_state;
    BF3_bml_markdown_state['bold']=0;
    BF3_bml_markdown_state['underline']=0;
    BF3_bml_markdown_state['emphasis']=0;
    BF3_bml_markdown_state['remove_nl']=0;
    BF3_bml_markdown_state['nl_to_tab']=0;
    BF3_bml_markdown_state['remove_tab']=0;
    BF3_bml_markdown_state['fg_colour']=;
    BF3_bml_markdown_state['bg_colour']=;
    [ -z $BF3_bml_markdown_settings ] && declare -A -g BF3_bml_markdown_settings;
    BF3_bml_markdown_settings['props_changed']='0';
    BF3_bml_markdown_VARS[themeId]='default';
    [ -z $BF3_bml_markdown_theme ] && declare -A -g BF3_bml_markdown_theme;
    function bml.markdown.__init () 
    { 
        bml.markdown.loadTheme
    };
    function bml.markdown.loadTheme () 
    { 
        BF3_bml_markdown_theme["${BF3_bml_markdown_VARS[themeId]}>>icon_danger"]="${BF3_chars_figs['SKULL']} ";
        BF3_bml_markdown_theme["${BF3_bml_markdown_VARS[themeId]}>>icon_info"]="${BF3_chars_figs['INFO_ROUND']} ";
        BF3_bml_markdown_theme["${BF3_bml_markdown_VARS[themeId]}>>icon_warning"]="${BF3_chars_figs['WARN']} ";
        BF3_bml_markdown_theme["${BF3_bml_markdown_VARS[themeId]}>>icon_success"]="${BF3_chars_figs['TICK']} "
    };
    function bml.markdown.indent () 
    { 
        echo "$1" | sed 's/^/    &/'
    };
    function bml.markdown.list () 
    { 
        echo "$1" | sed 's/^./  &/'
    };
    function bml.markdown.listItem () 
    { 
        echo "* $1"
    };
    function bml.markdown.list_complex () 
    { 
        local returnList="${1}";
        if [[ "$1" == *'{{#b:list}}'* ]]; then
            local lStart='{{#b:list}}';
            local lEnd='{{/b:list}}';
            local beforePart="${1%%$lStart*}";
            local afterPart="${1##*$lEnd}";
            local childLists="${1#*$lStart}";
            childLists="${childLists%$lEnd*}";
            returnList="${childLists//'{{#b:li}}'/'{{#b:li}}[[nestLevel]]'}";
            returnList="${beforePart}${lStart}${returnList}${lEnd}${afterPart}";
        fi;
        echo "${returnList}"
    };
    function bml.markdown.listItem_complex () 
    { 
        local cleaned="${1##*'[[nestLevel]]'}";
        local nested="${1/$cleaned/}";
        echo "${nested//'[[nestLevel]]'/ }* $cleaned"
    };
    function bml.markdown.icon () 
    { 
        echo "$(echo -en ${BF3_bml_markdown_theme[${BF3_bml_markdown_VARS[themeId]}>>icon_$1]})"
    };
    function bml.markdown.heading1 () 
    { 
        bml.markdown.printLine --text "# ${1}";
        bml.markdown.printLine --text ""
    };
    function bml.markdown.heading2 () 
    { 
        bml.markdown.printLine --text "## ${1}";
        bml.markdown.printLine --text ""
    };
    function bml.markdown.heading3 () 
    { 
        bml.markdown.printLine --text "### ${1}";
        bml.markdown.printLine --text ""
    };
    function bml.markdown.heading4 () 
    { 
        bml.markdown.printLine --text "#### ${1}";
        bml.markdown.printLine --text ""
    };
    function bml.markdown.heading5 () 
    { 
        bml.markdown.printLine --text "##### ${1}";
        bml.markdown.printLine --text ""
    };
    function bml.markdown.heading6 () 
    { 
        bml.markdown.printLine --text "###### ${1}";
        bml.markdown.printLine --text ""
    };
    function bml.markdown.figlet () 
    { 
        provision.require 'figlet' > /dev/null || { 
            echo 'Provision dependency "figlet" is not available in textprint'
        };
        bml.markdown.printLine --text '```';
        figlet "$1";
        bml.markdown.printLine --text '```'
    };
    function bml.markdown.dim () 
    { 
        echo "$1"
    };
    function bml.markdown.bold () 
    { 
        bml.markdown.print --text "__${1}__"
    };
    function bml.markdown.underline () 
    { 
        bml.markdown.print --text "_${1}_"
    };
    function bml.markdown.emphasis () 
    { 
        bml.markdown.print --text "_${1}_"
    };
    function bml.markdown.red () 
    { 
        echo "$1"
    };
    function bml.markdown.blue () 
    { 
        echo "$1"
    };
    function bml.markdown.lightBlue () 
    { 
        echo "$1"
    };
    function bml.markdown.cyan () 
    { 
        echo "$1"
    };
    function bml.markdown.yellow () 
    { 
        echo "$1"
    };
    function bml.markdown.green () 
    { 
        echo "$1"
    };
    function bml.markdown.orange () 
    { 
        echo "$1"
    };
    function bml.markdown.hr () 
    { 
        bml.markdown.printLine --text '---'
    };
    function bml.markdown.horiz () 
    { 
        local trimmedText;
        string.trim trimmedText "$1";
        local hText=${trimmedText//'
'/'	'};
        hText="$(echo "${hText}" | sed -e 's/	\+/	/g')";
        bml.markdown.print --text "${hText/	/}"
    };
    function bml.markdown.br () 
    { 
        bml.markdown.printLine --text ""
    };
    function bml.markdown.success () 
    { 
        echo "$1"
    };
    function bml.markdown.warning () 
    { 
        echo "$1"
    };
    function bml.markdown.danger () 
    { 
        echo "$1"
    };
    function bml.markdown.info () 
    { 
        echo "$1"
    };
    function bml.markdown.fmt () 
    { 
        local __prev_state;
        bml.markdown.getState __prev_state;
        bml.markdown.setProp --prop 'remove_nl' --state 1;
        bml.markdown.setProp --prop 'remove_tab' --state 1;
        bml.markdown.print --text "$1";
        bml.markdown.restoreState "${__prev_state}"
    };
    function bml.markdown.graphviz-dot () 
    { 
        provision.require 'visual.graphviz' > /dev/null || { 
            echo 'Provision dependency "visual.graphviz" is not available'
        };
        echo "![Diagram](data:image/jpeg;base64,$(dot -Tpng <(echo "$1") | base64 -w 0))"
    };
    function bml.markdown.box () 
    { 
        echo "";
        echo "$1" | fmt -w 80 | sed 's/^/> /';
        echo ""
    };
    function bml.markdown.setProp () 
    { 
        local -A __params;
        __params['prop']=;
        __params['state']=;
        params.get "$@";
        if [ "${BF3_bml_markdown_state[${__params['prop']}]}" == "${__params['state']}" ]; then
            return;
        fi;
        BF3_bml_markdown_state["${__params['prop']}"]="${__params['state']}";
        BF3_bml_markdown_settings['props_changed']='1'
    };
    function bml.markdown.setState () 
    { 
        local __tkey='default>>';
        BF3_bml_markdown_settings['props_changed']='0'
    };
    function bml.markdown.print () 
    { 
        local -A __params;
        __params['text']=;
        __params['nl']=0;
        __params['block']=0;
        params.get "$@";
        if [ "${BF3_bml_markdown_settings['props_changed']}" == '1' ]; then
            bml.markdown.setState;
        fi;
        local __textp;
        __textp="${__params['text']}";
        if [ "${BF3_bml_markdown_state['remove_nl']}" == '1' ] && [ "${__params['block']}" != '1' ]; then
            __textp=${__textp//'
'/};
        fi;
        if [ "${BF3_bml_markdown_state['remove_tab']}" == '1' ]; then
            __textp=${__textp//'	'/};
        fi;
        if [ "${__params['block']}" == '1' ]; then
            echo "";
        fi;
        bml.markdown.moPrint "${__textp}";
        if [ "${__params['block']}" == '1' ]; then
            echo "";
        fi;
        if [ "${__params['nl']}" == '1' ]; then
            echo "";
        fi
    };
    function bml.markdown.printLine () 
    { 
        bml.markdown.print "$@" --nl 1
    };
    function bml.markdown.getState () 
    { 
        local __ret_var=$1;
        local __prev_state_data=$(declare -p BF3_bml_markdown_state);
        __prev_state_data=${__prev_state_data/-A/-A -g};
        string.return_value "$__prev_state_data" $__ret_var
    };
    function bml.markdown.restoreState () 
    { 
        eval "$1";
        bml.markdown.setState
    };
    function moIsFunction () 
    { 
        declare -f -F $1 > /dev/null;
        return $?
    };
    function bml.markdown.moPrint () 
    { 
        local IFS=' 
	';
        moParse "$1" "" false
    }
}
bml.markdown.lightBlue () 
{ 
    echo "$1"
}
bml.markdown.list () 
{ 
    echo "$1" | sed 's/^./  &/'
}
bml.markdown.listItem () 
{ 
    echo "* $1"
}
bml.markdown.listItem_complex () 
{ 
    local cleaned="${1##*'[[nestLevel]]'}";
    local nested="${1/$cleaned/}";
    echo "${nested//'[[nestLevel]]'/ }* $cleaned"
}
bml.markdown.list_complex () 
{ 
    local returnList="${1}";
    if [[ "$1" == *'{{#b:list}}'* ]]; then
        local lStart='{{#b:list}}';
        local lEnd='{{/b:list}}';
        local beforePart="${1%%$lStart*}";
        local afterPart="${1##*$lEnd}";
        local childLists="${1#*$lStart}";
        childLists="${childLists%$lEnd*}";
        returnList="${childLists//'{{#b:li}}'/'{{#b:li}}[[nestLevel]]'}";
        returnList="${beforePart}${lStart}${returnList}${lEnd}${afterPart}";
    fi;
    echo "${returnList}"
}
bml.markdown.loadTheme () 
{ 
    BF3_bml_markdown_theme["${BF3_bml_markdown_VARS[themeId]}>>icon_danger"]="${BF3_chars_figs['SKULL']} ";
    BF3_bml_markdown_theme["${BF3_bml_markdown_VARS[themeId]}>>icon_info"]="${BF3_chars_figs['INFO_ROUND']} ";
    BF3_bml_markdown_theme["${BF3_bml_markdown_VARS[themeId]}>>icon_warning"]="${BF3_chars_figs['WARN']} ";
    BF3_bml_markdown_theme["${BF3_bml_markdown_VARS[themeId]}>>icon_success"]="${BF3_chars_figs['TICK']} "
}
bml.markdown.moPrint () 
{ 
    local IFS=' 
	';
    moParse "$1" "" false
}
bml.markdown.orange () 
{ 
    echo "$1"
}
bml.markdown.print () 
{ 
    local -A __params;
    __params['text']=;
    __params['nl']=0;
    __params['block']=0;
    params.get "$@";
    if [ "${BF3_bml_markdown_settings['props_changed']}" == '1' ]; then
        bml.markdown.setState;
    fi;
    local __textp;
    __textp="${__params['text']}";
    if [ "${BF3_bml_markdown_state['remove_nl']}" == '1' ] && [ "${__params['block']}" != '1' ]; then
        __textp=${__textp//'
'/};
    fi;
    if [ "${BF3_bml_markdown_state['remove_tab']}" == '1' ]; then
        __textp=${__textp//'	'/};
    fi;
    if [ "${__params['block']}" == '1' ]; then
        echo "";
    fi;
    bml.markdown.moPrint "${__textp}";
    if [ "${__params['block']}" == '1' ]; then
        echo "";
    fi;
    if [ "${__params['nl']}" == '1' ]; then
        echo "";
    fi
}
bml.markdown.printLine () 
{ 
    bml.markdown.print "$@" --nl 1
}
bml.markdown.red () 
{ 
    echo "$1"
}
bml.markdown.restoreState () 
{ 
    eval "$1";
    bml.markdown.setState
}
bml.markdown.setProp () 
{ 
    local -A __params;
    __params['prop']=;
    __params['state']=;
    params.get "$@";
    if [ "${BF3_bml_markdown_state[${__params['prop']}]}" == "${__params['state']}" ]; then
        return;
    fi;
    BF3_bml_markdown_state["${__params['prop']}"]="${__params['state']}";
    BF3_bml_markdown_settings['props_changed']='1'
}
bml.markdown.setState () 
{ 
    local __tkey='default>>';
    BF3_bml_markdown_settings['props_changed']='0'
}
bml.markdown.success () 
{ 
    echo "$1"
}
bml.markdown.underline () 
{ 
    bml.markdown.print --text "_${1}_"
}
bml.markdown.warning () 
{ 
    echo "$1"
}
bml.markdown.yellow () 
{ 
    echo "$1"
}
bml.preProcess () 
{ 
    "bml.${FUNCNAME[0]##*.}::args";
    local -A params;
    local -a unknown;
    parameters.load --namespace "bml.${FUNCNAME[0]##*.}" --ignore-unkown true --args "$@";
    local processedStr;
    processedStr=$(bml.printIteration1 "${params['text']}");
    processedStr=$(bml.printIteration2 "${processedStr}");
    processedStr=$(bml.printIteration3 "${processedStr}");
    echo -n "${processedStr}"
}
bml.preProcess::args () 
{ 
    parameters.add --key 'text' --namespace 'bml.preProcess' --name 'Raw BML Text' --alias '--text' --desc 'The raw BML text to process.' --required '1' --has-value 'y'
}
bml.print () 
{ 
    bml.preProcess "$@"
}
bml.printExample () 
{ 
    echo "$(bml.resource.get 'docs/example.bml')"
}
bml.printFile () 
{ 
    "bml.${FUNCNAME[0]##*.}::args";
    local -A params;
    local -a unknown;
    parameters.load --namespace "bml.${FUNCNAME[0]##*.}" --ignore-unkown true --args "$@";
    bml.preProcess --text "${params['text']}" | sed "s/^/${params['margin']}&/"
}
bml.printFile::args () 
{ 
    parameters.add --key 'text' --namespace 'bml.printFile' --name 'Raw BML Text' --alias '--text' --desc 'The raw BML text to process.' --required '1' --has-value 'y';
    parameters.add --key 'margin' --namespace 'bml.printFile' --name 'Add a margin' --alias '--margin' --alias '-m' --desc 'Adds a left margin to all output.  The default is 2 space.' + '  Is used when using "TERM" as the output format.' --has-value 'm' --default '  '
}
bml.printIteration1 () 
{ 
    local outStr="$1";
    local startDelim='{{';
    local startTempDelim='{#{';
    local endDelim='}}';
    local endTempDelim='}#}';
    local startStepDelim='{<{';
    local endStepDelim='}<}';
    local startLiteralDelim='{!<{';
    local endLiteralDelim='}!<}';
    outStr="${outStr//$startDelim/$startTempDelim}";
    outStr="${outStr//$endDelim/$endTempDelim}";
    outStr="${outStr//$startStepDelim/$startDelim}";
    outStr="${outStr//$endStepDelim/$endDelim}";
    outStr=$("${BF3_bml_VARS[output]}".print --text "$outStr");
    outStr="${outStr//$startTempDelim/$startDelim}";
    outStr="${outStr//$endTempDelim/$endDelim}";
    outStr="${outStr//$startLiteralDelim/$startStepDelim}";
    outStr="${outStr//$endLiteralDelim/$endStepDelim}";
    echo -n "${outStr}"
}
bml.printIteration2 () 
{ 
    local outStr="$1";
    local startDelim='{{';
    local endDelim='}}';
    local startStepDelim='{>{';
    local endStepDelim='}>}';
    local startLiteralDelim='{!>{';
    local endLiteralDelim='}!>}';
    outStr="${outStr//$startStepDelim/$startDelim}";
    outStr="${outStr//$endStepDelim/$endDelim}";
    outStr=$("${BF3_bml_VARS[output]}".print --text "$outStr");
    outStr="${outStr//$startLiteralDelim/$startStepDelim}";
    outStr="${outStr//$endLiteralDelim/$endStepDelim}";
    echo -n "${outStr}"
}
bml.printIteration3 () 
{ 
    local outStr="$1";
    local startDelim='{{';
    local endDelim='}}';
    local startStepDelim='{!{';
    local endStepDelim='}!}';
    local startLiteralDelim='{!!{';
    local endLiteralDelim='}!!}';
    outStr="${outStr//$startStepDelim/$startDelim}";
    outStr="${outStr//$endStepDelim/$endDelim}";
    outStr="${outStr//$startLiteralDelim/$startStepDelim}";
    outStr="${outStr//$endLiteralDelim/$endStepDelim}";
    echo -n "${outStr}"
}
bml.resource.docs:-:example.bml () 
{ 
    cat  <<'EOF'
{{#b:h1}}Heading 1{{/b:h1}}
{{#b:b}}This is some bold text{{/b:b}}

And here is some unstyled text.

Some normal paragraph text.  Followed by some {{#b:u}}underlined words.{{/b:u}}


{{#b:h2}}A Heading 2{{/b:h2}}

Here is a simple list:
{{#b:list}}
{{#b:li}}A list item{{/b:li}}
{{#b:li}}A second item{{/b:li}}
{{#b:list}}
{{#b:li}}A nested list{{/b:li}}
{{#b:li}}With multiple items{{/b:li}}
{{/b:list}}

{{#b:li}}And Number 3{{/b:li}}
{{/b:list}}

{{b:br}}
Here is a more complex example:

{{#b:list}}
{{#b:li}}{{#b:u}}Some {{#b:warning}}inline{{/b:warning}} styling{{/b:u}}{{/b:li}}
{{#b:li}}An inline icon {{#b:danger}}{{#b:icon}}warning{{/b:icon}}{{/b:danger}} with colour{{/b:li}}
{{#b:list}}
{{#b:li}}{{#b:b}}Text with {{#b:success}}colours{{/b:success}}{{/b:b}} and {{#b:em}}emphasis!{{/b:em}}{{/b:li}}
{{/b:list}}

{{#b:li}}And Number 3{{/b:li}}
{{/b:list}}

{{b:br}}
{{#b:h3}}A Heading 3{{/b:h3}}

{{#b:info}}Box it up!{{/b:info}}
Use the 'box' tag to highlight important info.

{{#b:box}}{{#b:b}}{{#b:info}}A Box for Content{{/b:info}}{{/b:b}}

You can {{#b:u}}use markup inside{{/b:u}} the box too.
{{#b:d}}    It will attempt to wrap long text if it can.{{/b:d}}


{{/b:box}}

{{b:br}}
{{b:hr}}
{{b:br}}
{{#b:h2}}Draw Diagrams{{/b:h2}}
You can use BML to draw inline diagrams using the dot language with graphviz.

{{#b:h5}}A simple Diagram Example{{/b:h5}}
{{#b:u}}NOTE:{{/b:u}} This graph is made using the graphiz-dot tag and is rendered in both terminal and Markdown outputs.
It will render as ASCII in the terminal or as an embedded base64 png in Markdown.


{{#b:graphviz-dot}}
digraph g {

    graph [fontname = "helvetica bold"];
    node [fontname = "helvetica"];
    edge [fontname = "helvetica"];
    rankdir = TB;

    labelloc="t";
    label="Example Workflow";

    a[label="Step 1", shape="invhouse"]
    b[label="Decision", shape="diamond"]
    c[label="Some Input", shape="rect"]
    d[label="Failed", shape="rect"]
    e[label="Imported", shape="rect"]

    {rank = same; a;}
    {rank = same; c; b;}
    {rank = same; d; e;}

    a->b;
    b->c[label="Valid"];
    c->a[dir=both, label="Retry"];
    c->e[label="OK"]
    b->d[label="Invalid"];

}
{{/b:graphviz-dot}}
{{b:br}}
{{b:hr}}

{{#b:h2}}Layout{{/b:h2}}

Use the horiz tag to change the direction of a list:

{{#b:horiz}}
{{#b:list}}
{{#b:li}}This a list{{/b:li}}
{{#b:li}}Wrapped in the horiz tag{{/b:li}}
{{#b:li}}So the items display{{/b:li}}
{{#b:li}}Side by side{{/b:li}}
{{#b:li}}Instead of vertically{{/b:li}}
{{/b:list}}
{{/b:horiz}}

{{b:br}}
Or you can even use it on lines of text

{{#b:horiz}}
{{#b:icon}}success{{/b:icon}} A List
{{#b:icon}}info{{/b:icon}}  Of Random
{{#b:icon}}info{{/b:icon}}  Words and Icons
{{#b:icon}}danger{{/b:icon}} On Separate
{{#b:icon}}success{{/b:icon}} Lines
{{/b:horiz}}


{{#b:h4}}ASCII Banners:{{/b:h4}}

You can use figlet for big ASCII style banners
{{#b:figlet}}Figlet!{{/b:figlet}}

{{b:br}}
{{b:hr}}
{{b:br}}

{{#b:h2}}Tag Processing{{/b:h2}}

{{#b:h4}}Normal Tags{{/b:h4}}
For most cases you will want to use the standard start and end tag delimiters.
eg: "{!{" and "}!}"

{!{#b:b}!}Bold Text{!{/b:b}!}

{{#b:b}}Bold Text{{/b:b}}

However sometimes you may wish for tags in the document to be processed in a certain sequence or not at all.

{{#b:h4}}Before Tags{{/b:h4}}
These will be processed for the entire document first, before normal tags are executed.

{!<{#b:b}!<}Parsed First!{!<{/b:b}!<}

{<{#b:b}<}Parsed First!{<{/b:b}<}

{{#b:h4}}After Tags{{/b:h4}}
These will be processed for the entire document after the "before" and "normal" tags are executed.

{!>{#b:u}!>}Parsed After!{!>{/b:u}!>}

{>{#b:u}>}Parsed After!{>{/b:u}>}

{{#b:h4}}Never Tags{{/b:h4}}
These tags will not be processed.
This can be useful when you want to literally represent tag delimiters within a document.
Or you are pre-compiling parts of the document to precache the static parts and want to only process the dynamic parts of the document at runtime.

{!!{#b:u}!!}Parsed Never!{!!{/b:u}!!}

{!{#b:u}!}Parsed Never!{!{/b:u}!}
EOF

}
bml.resource.get () 
{ 
    local __file_path="$1";
    local __wrap_function="bml.resource.${__file_path////:-:}";
    import.functionExists "${__wrap_function}" || { 
        logger.error --message "Resource '${__file_path}' not found.";
        logger.die
    };
    $__wrap_function
}
bml.shell.__init () 
{ 
    bml.shell.loadTheme
}
bml.shell.blue () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'fg_colour' --state 'blue';
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.bold () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'bold' --state 1;
    bml.shell.print --text "${1}";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.border () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'dim' --state 1;
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.box () 
{ 
    echo "";
    local longest;
    longest=$(echo "$1" | sed -e 's/{{[^}}]*}}//g' | wc -L);
    local div_width;
    let div_width=longest+2;
    local top_line;
    string.padding top_line "${BF3_chars_box['DBL_EW']}" "$div_width";
    echo "$(echo -e ${BF3_chars_box['DBL_SE']})${top_line}$(echo -e ${BF3_chars_box['DBL_SW']})";
    local line_count;
    line_count=$(echo "$1" | wc -l);
    local count=0;
    local txt_line;
    while read -r txt_line; do
        local pdded;
        local no_tags;
        no_tags=$(echo "$txt_line" | sed -e 's/{{[^}}]*}}//g');
        local no_tags_len=${#no_tags};
        local padstr_len;
        let padstr_len=longest-no_tags_len;
        string.padding pdded ' ' "$padstr_len";
        let count=count+1;
        if [ "$count" == "$line_count" ] && [ "$txt_line" == '' ]; then
            break;
        else
            echo "$(echo -e ${BF3_chars_box['DBL_NS']}) ${txt_line}${pdded} $(echo -e ${BF3_chars_box['DBL_NS']})";
        fi;
    done <<< "$1";
    echo "$(echo -e ${BF3_chars_box['DBL_NE']})${top_line}$(echo -e ${BF3_chars_box['DBL_NW']})"
}
bml.shell.br () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'remove_nl' --state '0';
    bml.shell.print --text "" --nl 1;
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.cyan () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'fg_colour' --state 'cyan';
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.danger () 
{ 
    bml.shell.red "$@"
}
bml.shell.dim () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'dim' --state 1;
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.emphasis () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'emphasis' --state 1;
    bml.shell.print --text "${1}";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.figlet () 
{ 
    provision.require 'figlet' > /dev/null || { 
        echo 'Provision dependency "figlet" is not available in textprint'
    };
    figlet "$1"
}
bml.shell.fmt () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'remove_nl' --state 1;
    bml.shell.setProp --prop 'remove_tab' --state 1;
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.getState () 
{ 
    local __ret_var=$1;
    local __prev_state_data=$(declare -p BF3_bml_shell_state);
    __prev_state_data=${__prev_state_data/-A/-A -g};
    string.return_value "$__prev_state_data" $__ret_var
}
bml.shell.graphviz-dot () 
{ 
    provision.require 'visual.graphviz.graph_easy' > /dev/null || { 
        echo 'Provision dependency "visual.graphviz.graph_easy" is not available'
    };
    graph-easy --from graphviz --as boxart <(echo "$1")
}
bml.shell.green () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'fg_colour' --state 'green';
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.heading1 () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'bold' --state 1;
    bml.shell.setProp --prop 'fg_colour' --state 'orange';
    local heading="$(figlet -f standard.flf "$1")";
    bml.shell.print --text "$heading";
    bml.shell.restoreState "${__prev_state}";
    bml.shell.printLine --text "";
    bml.shell.hr
}
bml.shell.heading2 () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'bold' --state 1;
    bml.shell.setProp --prop 'fg_colour' --state 'orange';
    local heading="$(figlet -f small.flf "$1")";
    bml.shell.print --text "$heading";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.heading3 () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'fg_colour' --state 'orange';
    local heading="$(figlet -f mini.flf "$1")";
    bml.shell.print --text "$heading";
    bml.shell.restoreState "${__prev_state}";
    bml.shell.printLine --text ""
}
bml.shell.heading4 () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'bold' --state 1;
    bml.shell.setProp --prop 'underline' --state 1;
    bml.shell.setProp --prop 'fg_colour' --state 'blue';
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.heading5 () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'bold' --state 1;
    bml.shell.setProp --prop 'fg_colour' --state 'blue';
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.heading6 () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'underline' --state 1;
    bml.shell.setProp --prop 'fg_colour' --state 'blue';
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.horiz () 
{ 
    local __hText=${1//'
'/'	'};
    __hText="$(echo "${__hText}" | sed -e 's/	\+/	/g')";
    bml.shell.print --text "${__hText}"
}
bml.shell.hr () 
{ 
    local defaultChar="${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>hr-char]}";
    local char="${1:-$defaultChar}";
    local hr;
    string.padding hr "${char}" 80;
    bml.shell.printLine --text "${hr}"
}
bml.shell.icon () 
{ 
    echo "$(echo -en ${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>icon_$1]})"
}
bml.shell.indent () 
{ 
    echo "$1" | sed 's/^/    &/'
}
bml.shell.info () 
{ 
    bml.shell.blue "$@"
}
bml.shell.init () 
{ 
    if [ -z $BF3_bml_shell_VARS_REAL ]; then
        declare -A -g BF3_bml_shell_VARS_REAL;
        declare -g -n BF3_bml_shell_VARS=BF3_bml_shell_VARS_REAL;
    fi;
    BF3_bml_shell_VARS[namespace]='bml.shell';
    [ -z $BF3_bml_shell_state ] && declare -A -g BF3_bml_shell_state;
    BF3_bml_shell_state['bold']=0;
    BF3_bml_shell_state['underline']=0;
    BF3_bml_shell_state['emphasis']=0;
    BF3_bml_shell_state['remove_nl']=0;
    BF3_bml_shell_state['nl_to_tab']=0;
    BF3_bml_shell_state['remove_tab']=0;
    BF3_bml_shell_state['fg_colour']=;
    BF3_bml_shell_state['bg_colour']=;
    [ -z $BF3_bml_shell_cached ] && declare -A -g BF3_bml_shell_cached;
    [ -z $BF3_bml_shell_settings ] && declare -A -g BF3_bml_shell_settings;
    BF3_bml_shell_settings['props_changed']='0';
    BF3_bml_shell_VARS[themeId]='default';
    [ -z $BF3_bml_shell_theme ] && declare -A -g BF3_bml_shell_theme;
    function bml.shell.__init () 
    { 
        bml.shell.loadTheme
    };
    function bml.shell.loadTheme () 
    { 
        BF3_bml_shell_cached['bold']=$(tput bold);
        BF3_bml_shell_cached['reset']=$(tput sgr0);
        BF3_bml_shell_cached['dim']=$(tput dim);
        BF3_bml_shell_cached['underline']=$(tput smul);
        BF3_bml_shell_cached['removeUnderline']=$(tput rmul);
        BF3_bml_shell_cached['em']=$(tput smso);
        BF3_bml_shell_cached['removeEm']=$(tput rmso);
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>icon_danger"]="${BF3_chars_figs['SKULL']} ";
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>icon_info"]="${BF3_chars_figs['INFO_ROUND']} ";
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>icon_warning"]="${BF3_chars_figs['WARN']} ";
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>icon_success"]="${BF3_chars_figs['TICK']} ";
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>hr-char"]="${BF3_chars_box['THIN_EW']} ";
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>red"]='167';
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>purple"]='67';
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>blue"]='24';
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>light-blue"]='109';
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>yellow"]='100';
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>green"]='47';
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>orange"]='173';
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>cyan"]='66';
        BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>default"]='121';
        bml.shell.setProp --prop 'fg_colour' --state 'default'
    };
    function bml.shell.indent () 
    { 
        echo "$1" | sed 's/^/    &/'
    };
    function bml.shell.list () 
    { 
        echo "$1" | sed 's/^./    &/'
    };
    function bml.shell.listItem () 
    { 
        echo "$(echo -en ${BF3_chars_figs['SMALL_CIRCLE']}) $1"
    };
    function bml.shell.icon () 
    { 
        echo "$(echo -en ${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>icon_$1]})"
    };
    function bml.shell.heading1 () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'bold' --state 1;
        bml.shell.setProp --prop 'fg_colour' --state 'orange';
        local heading="$(figlet -f standard.flf "$1")";
        bml.shell.print --text "$heading";
        bml.shell.restoreState "${__prev_state}";
        bml.shell.printLine --text "";
        bml.shell.hr
    };
    function bml.shell.heading2 () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'bold' --state 1;
        bml.shell.setProp --prop 'fg_colour' --state 'orange';
        local heading="$(figlet -f small.flf "$1")";
        bml.shell.print --text "$heading";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.heading3 () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'fg_colour' --state 'orange';
        local heading="$(figlet -f mini.flf "$1")";
        bml.shell.print --text "$heading";
        bml.shell.restoreState "${__prev_state}";
        bml.shell.printLine --text ""
    };
    function bml.shell.heading4 () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'bold' --state 1;
        bml.shell.setProp --prop 'underline' --state 1;
        bml.shell.setProp --prop 'fg_colour' --state 'blue';
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.heading5 () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'bold' --state 1;
        bml.shell.setProp --prop 'fg_colour' --state 'blue';
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.heading6 () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'underline' --state 1;
        bml.shell.setProp --prop 'fg_colour' --state 'blue';
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.figlet () 
    { 
        provision.require 'figlet' > /dev/null || { 
            echo 'Provision dependency "figlet" is not available in textprint'
        };
        figlet "$1"
    };
    function bml.shell.dim () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'dim' --state 1;
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.border () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'dim' --state 1;
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.bold () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'bold' --state 1;
        bml.shell.print --text "${1}";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.underline () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'underline' --state 1;
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.emphasis () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'emphasis' --state 1;
        bml.shell.print --text "${1}";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.red () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'fg_colour' --state 'red';
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.blue () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'fg_colour' --state 'blue';
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.lightBlue () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'fg_colour' --state 'light-blue';
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.cyan () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'fg_colour' --state 'cyan';
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.yellow () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'fg_colour' --state 'yellow';
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.green () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'fg_colour' --state 'green';
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.orange () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'fg_colour' --state 'orange';
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.hr () 
    { 
        local defaultChar="${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>hr-char]}";
        local char="${1:-$defaultChar}";
        local hr;
        string.padding hr "${char}" 80;
        bml.shell.printLine --text "${hr}"
    };
    function bml.shell.horiz () 
    { 
        local __hText=${1//'
'/'	'};
        __hText="$(echo "${__hText}" | sed -e 's/	\+/	/g')";
        bml.shell.print --text "${__hText}"
    };
    function bml.shell.br () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'remove_nl' --state '0';
        bml.shell.print --text "" --nl 1;
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.success () 
    { 
        bml.shell.green "$@"
    };
    function bml.shell.warning () 
    { 
        bml.shell.orange "$@"
    };
    function bml.shell.danger () 
    { 
        bml.shell.red "$@"
    };
    function bml.shell.info () 
    { 
        bml.shell.blue "$@"
    };
    function bml.shell.fmt () 
    { 
        local __prev_state;
        bml.shell.getState __prev_state;
        bml.shell.setProp --prop 'remove_nl' --state 1;
        bml.shell.setProp --prop 'remove_tab' --state 1;
        bml.shell.print --text "$1";
        bml.shell.restoreState "${__prev_state}"
    };
    function bml.shell.graphviz-dot () 
    { 
        provision.require 'visual.graphviz.graph_easy' > /dev/null || { 
            echo 'Provision dependency "visual.graphviz.graph_easy" is not available'
        };
        graph-easy --from graphviz --as boxart <(echo "$1")
    };
    function bml.shell.box () 
    { 
        echo "";
        local longest;
        longest=$(echo "$1" | sed -e 's/{{[^}}]*}}//g' | wc -L);
        local div_width;
        let div_width=longest+2;
        local top_line;
        string.padding top_line "${BF3_chars_box['DBL_EW']}" "$div_width";
        echo "$(echo -e ${BF3_chars_box['DBL_SE']})${top_line}$(echo -e ${BF3_chars_box['DBL_SW']})";
        local line_count;
        line_count=$(echo "$1" | wc -l);
        local count=0;
        local txt_line;
        while read -r txt_line; do
            local pdded;
            local no_tags;
            no_tags=$(echo "$txt_line" | sed -e 's/{{[^}}]*}}//g');
            local no_tags_len=${#no_tags};
            local padstr_len;
            let padstr_len=longest-no_tags_len;
            string.padding pdded ' ' "$padstr_len";
            let count=count+1;
            if [ "$count" == "$line_count" ] && [ "$txt_line" == '' ]; then
                break;
            else
                echo "$(echo -e ${BF3_chars_box['DBL_NS']}) ${txt_line}${pdded} $(echo -e ${BF3_chars_box['DBL_NS']})";
            fi;
        done <<< "$1";
        echo "$(echo -e ${BF3_chars_box['DBL_NE']})${top_line}$(echo -e ${BF3_chars_box['DBL_NW']})"
    };
    function bml.shell.setProp () 
    { 
        local -A __params;
        __params['prop']=;
        __params['state']=;
        params.get "$@";
        if [ "${BF3_bml_shell_state[${__params['prop']}]}" == "${__params['state']}" ]; then
            return;
        fi;
        BF3_bml_shell_state["${__params['prop']}"]="${__params['state']}";
        BF3_bml_shell_settings['props_changed']='1'
    };
    function bml.shell.setState () 
    { 
        BF3_bml_shell_settings['props_changed']='0';
        local __tkey='default>>';
        bml.shell.setReset;
        if [ "${BF3_bml_shell_state['bold']}" == '1' ]; then
            bml.shell.setBold;
        fi;
        if [ "${BF3_bml_shell_state['dim']}" == '1' ]; then
            bml.shell.setDim;
        fi;
        if [ "${BF3_bml_shell_state['underline']}" == '1' ]; then
            bml.shell.setUnderline;
        else
            bml.shell.setRemoveUnderline;
        fi;
        if [ "${BF3_bml_shell_state['emphasis']}" == '1' ]; then
            bml.shell.setEm;
        else
            bml.shell.setRemoveEm;
        fi;
        if [ "${BF3_bml_shell_state['fg_colour']}" == 'red' ]; then
            tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>red]}";
        else
            if [ "${BF3_bml_shell_state['fg_colour']}" == 'blue' ]; then
                tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>blue]}";
            else
                if [ "${BF3_bml_shell_state['fg_colour']}" == 'yellow' ]; then
                    tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>yellow]}";
                else
                    if [ "${BF3_bml_shell_state['fg_colour']}" == 'green' ]; then
                        tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>green]}";
                    else
                        if [ "${BF3_bml_shell_state['fg_colour']}" == 'orange' ]; then
                            tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>orange]}";
                        else
                            if [ "${BF3_bml_shell_state['fg_colour']}" == 'light-blue' ]; then
                                tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>light-blue]}";
                            else
                                if [ "${BF3_bml_shell_state['fg_colour']}" == 'cyan' ]; then
                                    tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>cyan]}";
                                else
                                    if [ "${BF3_bml_shell_state['fg_colour']}" == 'default' ]; then
                                        tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>default]}";
                                    fi;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi
    };
    function bml.shell.setBold () 
    { 
        echo -n "${BF3_bml_shell_cached['bold']}"
    };
    function bml.shell.setDim () 
    { 
        echo -n "${BF3_bml_shell_cached['dim']}"
    };
    function bml.shell.setReset () 
    { 
        echo -n "${BF3_bml_shell_cached['reset']}"
    };
    function bml.shell.setUnderline () 
    { 
        echo -n "${BF3_bml_shell_cached['underline']}"
    };
    function bml.shell.setRemoveUnderline () 
    { 
        echo -n "${BF3_bml_shell_cached['removeUnderline']}"
    };
    function bml.shell.setEm () 
    { 
        echo -n "${BF3_bml_shell_cached['em']}"
    };
    function bml.shell.setRemoveEm () 
    { 
        echo -n "${BF3_bml_shell_cached['removeEm']}"
    };
    function bml.shell.print () 
    { 
        local -A __params;
        __params['text']=;
        __params['nl']=0;
        __params['block']=0;
        params.get "$@";
        if [ "${BF3_bml_shell_settings['props_changed']}" == '1' ]; then
            bml.shell.setState;
        fi;
        local __textp;
        __textp="${__params['text']}";
        if [ "${BF3_bml_shell_state['remove_nl']}" == '1' ] && [ "${__params['block']}" != '1' ]; then
            __textp=${__textp//'
'/};
        fi;
        if [ "${BF3_bml_shell_state['remove_tab']}" == '1' ]; then
            __textp=${__textp//'	'/};
        fi;
        if [ "${__params['block']}" == '1' ]; then
            echo "";
        fi;
        bml.shell.moPrint "${__textp}";
        if [ "${__params['block']}" == '1' ]; then
            echo "";
        fi;
        if [ "${__params['nl']}" == '1' ]; then
            echo "";
        fi
    };
    function bml.shell.printLine () 
    { 
        bml.shell.print "$@" --nl 1
    };
    function bml.shell.getState () 
    { 
        local __ret_var=$1;
        local __prev_state_data=$(declare -p BF3_bml_shell_state);
        __prev_state_data=${__prev_state_data/-A/-A -g};
        string.return_value "$__prev_state_data" $__ret_var
    };
    function bml.shell.restoreState () 
    { 
        eval "$1";
        bml.shell.setState
    };
    function moIsFunction () 
    { 
        declare -f -F $1 > /dev/null;
        return $?
    };
    function bml.shell.moPrint () 
    { 
        local IFS=' 
	';
        moParse "$1" "" false
    }
}
bml.shell.lightBlue () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'fg_colour' --state 'light-blue';
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.list () 
{ 
    echo "$1" | sed 's/^./    &/'
}
bml.shell.listItem () 
{ 
    echo "$(echo -en ${BF3_chars_figs['SMALL_CIRCLE']}) $1"
}
bml.shell.loadTheme () 
{ 
    BF3_bml_shell_cached['bold']=$(tput bold);
    BF3_bml_shell_cached['reset']=$(tput sgr0);
    BF3_bml_shell_cached['dim']=$(tput dim);
    BF3_bml_shell_cached['underline']=$(tput smul);
    BF3_bml_shell_cached['removeUnderline']=$(tput rmul);
    BF3_bml_shell_cached['em']=$(tput smso);
    BF3_bml_shell_cached['removeEm']=$(tput rmso);
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>icon_danger"]="${BF3_chars_figs['SKULL']} ";
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>icon_info"]="${BF3_chars_figs['INFO_ROUND']} ";
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>icon_warning"]="${BF3_chars_figs['WARN']} ";
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>icon_success"]="${BF3_chars_figs['TICK']} ";
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>hr-char"]="${BF3_chars_box['THIN_EW']} ";
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>red"]='167';
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>purple"]='67';
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>blue"]='24';
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>light-blue"]='109';
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>yellow"]='100';
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>green"]='47';
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>orange"]='173';
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>cyan"]='66';
    BF3_bml_shell_theme["${BF3_bml_shell_VARS[themeId]}>>default"]='121';
    bml.shell.setProp --prop 'fg_colour' --state 'default'
}
bml.shell.moPrint () 
{ 
    local IFS=' 
	';
    moParse "$1" "" false
}
bml.shell.orange () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'fg_colour' --state 'orange';
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.print () 
{ 
    local -A __params;
    __params['text']=;
    __params['nl']=0;
    __params['block']=0;
    params.get "$@";
    if [ "${BF3_bml_shell_settings['props_changed']}" == '1' ]; then
        bml.shell.setState;
    fi;
    local __textp;
    __textp="${__params['text']}";
    if [ "${BF3_bml_shell_state['remove_nl']}" == '1' ] && [ "${__params['block']}" != '1' ]; then
        __textp=${__textp//'
'/};
    fi;
    if [ "${BF3_bml_shell_state['remove_tab']}" == '1' ]; then
        __textp=${__textp//'	'/};
    fi;
    if [ "${__params['block']}" == '1' ]; then
        echo "";
    fi;
    bml.shell.moPrint "${__textp}";
    if [ "${__params['block']}" == '1' ]; then
        echo "";
    fi;
    if [ "${__params['nl']}" == '1' ]; then
        echo "";
    fi
}
bml.shell.printLine () 
{ 
    bml.shell.print "$@" --nl 1
}
bml.shell.red () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'fg_colour' --state 'red';
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.restoreState () 
{ 
    eval "$1";
    bml.shell.setState
}
bml.shell.setBold () 
{ 
    echo -n "${BF3_bml_shell_cached['bold']}"
}
bml.shell.setDim () 
{ 
    echo -n "${BF3_bml_shell_cached['dim']}"
}
bml.shell.setEm () 
{ 
    echo -n "${BF3_bml_shell_cached['em']}"
}
bml.shell.setProp () 
{ 
    local -A __params;
    __params['prop']=;
    __params['state']=;
    params.get "$@";
    if [ "${BF3_bml_shell_state[${__params['prop']}]}" == "${__params['state']}" ]; then
        return;
    fi;
    BF3_bml_shell_state["${__params['prop']}"]="${__params['state']}";
    BF3_bml_shell_settings['props_changed']='1'
}
bml.shell.setRemoveEm () 
{ 
    echo -n "${BF3_bml_shell_cached['removeEm']}"
}
bml.shell.setRemoveUnderline () 
{ 
    echo -n "${BF3_bml_shell_cached['removeUnderline']}"
}
bml.shell.setReset () 
{ 
    echo -n "${BF3_bml_shell_cached['reset']}"
}
bml.shell.setState () 
{ 
    BF3_bml_shell_settings['props_changed']='0';
    local __tkey='default>>';
    bml.shell.setReset;
    if [ "${BF3_bml_shell_state['bold']}" == '1' ]; then
        bml.shell.setBold;
    fi;
    if [ "${BF3_bml_shell_state['dim']}" == '1' ]; then
        bml.shell.setDim;
    fi;
    if [ "${BF3_bml_shell_state['underline']}" == '1' ]; then
        bml.shell.setUnderline;
    else
        bml.shell.setRemoveUnderline;
    fi;
    if [ "${BF3_bml_shell_state['emphasis']}" == '1' ]; then
        bml.shell.setEm;
    else
        bml.shell.setRemoveEm;
    fi;
    if [ "${BF3_bml_shell_state['fg_colour']}" == 'red' ]; then
        tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>red]}";
    else
        if [ "${BF3_bml_shell_state['fg_colour']}" == 'blue' ]; then
            tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>blue]}";
        else
            if [ "${BF3_bml_shell_state['fg_colour']}" == 'yellow' ]; then
                tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>yellow]}";
            else
                if [ "${BF3_bml_shell_state['fg_colour']}" == 'green' ]; then
                    tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>green]}";
                else
                    if [ "${BF3_bml_shell_state['fg_colour']}" == 'orange' ]; then
                        tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>orange]}";
                    else
                        if [ "${BF3_bml_shell_state['fg_colour']}" == 'light-blue' ]; then
                            tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>light-blue]}";
                        else
                            if [ "${BF3_bml_shell_state['fg_colour']}" == 'cyan' ]; then
                                tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>cyan]}";
                            else
                                if [ "${BF3_bml_shell_state['fg_colour']}" == 'default' ]; then
                                    tput setaf "${BF3_bml_shell_theme[${BF3_bml_shell_VARS[themeId]}>>default]}";
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi
}
bml.shell.setUnderline () 
{ 
    echo -n "${BF3_bml_shell_cached['underline']}"
}
bml.shell.success () 
{ 
    bml.shell.green "$@"
}
bml.shell.underline () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'underline' --state 1;
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
bml.shell.warning () 
{ 
    bml.shell.orange "$@"
}
bml.shell.yellow () 
{ 
    local __prev_state;
    bml.shell.getState __prev_state;
    bml.shell.setProp --prop 'fg_colour' --state 'yellow';
    bml.shell.print --text "$1";
    bml.shell.restoreState "${__prev_state}"
}
build.transpiler.getOuterNamespace () 
{ 
    local originalNamespace="$1";
    local importOp="$2";
    local targetNs="$3";
    local nameSpaceOuter="${targetNs}";
    local namespaceAs="${originalNamespace}";
    [ "${importOp}" == 'mixin' ] && { 
        namesSpaceAs="$targetNs";
        nameSpaceOuter="${namesSpaceAs}.mixin.${originalNamespace}"
    };
    [ "${importOp}" == 'extend' ] && { 
        namesSpaceAs="$targetNs";
        nameSpaceOuter="${namesSpaceAs}.extend.${originalNamespace}"
    };
    echo "${nameSpaceOuter}"
}
build.transpiler.getSuperNamespace () 
{ 
    local originalNamespace="$1";
    local importOp="$2";
    local targetNs="$3";
    local nameSpaceOuter="${targetNs}";
    local namespaceAs="${originalNamespace}";
    [ "${importOp}" == 'extend' ] && { 
        namesSpaceAs="$targetNs";
        nameSpaceOuter="${namesSpaceAs}._super.${originalNamespace}"
    };
    echo "${nameSpaceOuter}"
}
build.transpiler.init () 
{ 
    function build.transpiler.transpile () 
    { 
        local sourceFile="$1";
        local originalNamespace="$2";
        local operation="${3}";
        local nSpaceAlias="$4";
        local nSpace="${originalNamespace}";
        [ "${operation}" == 'as' ] && { 
            nSpace="$nSpaceAlias"
        };
        [ "${operation}" == 'mixin' ] && { 
            nSpace="$nSpaceAlias"
        };
        [ "${operation}" == 'extend' ] && { 
            nSpace="$nSpaceAlias"
        };
        build.transpiler.logToErr "importing ${originalNamespace} ${operation} ${nSpace}";
        local baseNamespace="${nSpace%%._super*}";
        local nsLine=$(grep -n "^@namespace" "${sourceFile}");
        local lineNum="${nsLine%%:*}";
        local varsArrName="BF3_${baseNamespace//./_}_VARS";
        local nSpaceOuter=$(build.transpiler.getOuterNamespace "${originalNamespace}" "${operation}" "${nSpace}" );
        build.transpiler.logToErr "${nSpaceOuter}";
        local superNspace=$(build.transpiler.getSuperNamespace "${originalNamespace}" "${operation}" "${nSpace}" );
        build.transpiler.logToErr "${superNsapce}";
        local funcEnd="()";
        local sourceCode=$(tail -n+"${lineNum}" "${sourceFile}");
        local wrapped=$(echo "${sourceCode}" | sed "s/@namespace//");
        local varsArrCode="if [ -z  \$${varsArrName}_REAL ]; then\n";
        varsArrCode="${varsArrCode}declare -A -g ${varsArrName}_REAL\n";
        varsArrCode="${varsArrCode}declare -g -n ${varsArrName}=${varsArrName}_REAL\n";
        varsArrCode="${varsArrCode}fi\n\n";
        varsArrCode="${varsArrCode}@this[namespace]='$baseNamespace'\n\n";
        wrapped="${varsArrCode}\n${wrapped}\n";
        wrapped="${nSpaceOuter}.init${funcEnd} {\n${wrapped}\n}";
        function transpile_realGet () 
        { 
            local source="$1";
            echo -e "$source" | perl -pe 's%(\@get=>.*?\[)% ($_x = $1) =~ s/\./_/g; $_x %eg' | sed "s/@get=>\([^[]*\)\[\([^]]*\)\]/\${BF3_\1_VARS_REAL['\2']}/g"
        };
        function transpile_realSet () 
        { 
            local source="$1";
            echo -e "$source" | perl -pe 's%(\@set=>.*?\[)% ($_x = $1) =~ s/\./_/g; $_x %eg' | sed "s/@set=>\([^[]*\)\[\([^]]*\)\]=/BF3_\1_VARS_REAL['\2']=/g"
        };
        function transpile_arrGet () 
        { 
            local source="$1";
            echo -e "$source" | perl -pe 's%(\@get\(.*?[\)|\]])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@get(\([^)]*\))/\${BF3_\1}/g"
        };
        function transpile_assocKeys () 
        { 
            local source="$1";
            echo -e "$source" | perl -pe 's%(\@keys\(.*?[\)|\]])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@keys(\([^)]*\))/\${!BF3_\1[@]}/g"
        };
        function transpile_arrCreate () 
        { 
            local source="$1";
            echo -e "$source" | perl -pe 's%(\@create\[\]\(.*?[\)|\]])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@create\[\](\([^)]*\))/\[ -z \$BF3_\1 ] \&\& declare -a -g BF3_\1/g"
        };
        function transpile_assocCreate () 
        { 
            local source="$1";
            echo -e "$source" | perl -pe 's%(\@create\{\}\(.*?[\)|\]])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@create{}(\([^)]*\))/\[ -z \$BF3_\1 ] \&\& declare -A -g BF3_\1/g"
        };
        function transpile_arrSet () 
        { 
            local source="$1";
            echo -e "$source" | perl -pe 's%(\@set\(.*?[\)|\]])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@set(\([^)]*\))=/\BF3_\1=/g"
        };
        function transpile_arrAdd () 
        { 
            local source="$1";
            echo -e "$source" | perl -pe 's%(\@add\(.*?[\)])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@add(\([^)]*\))+=/\BF3_\1+=/g"
        };
        function transpile_arrToStr () 
        { 
            local source="$1";
            echo -e "$source" | perl -pe 's%(\@arrStr\(.*?[\)])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@arrStr(\([^)]*\))/\declare -p BF3_\1/g"
        };
        function transpile_arrExpand () 
        { 
            local source="$1";
            echo -e "$source" | perl -pe 's%(\@expand\(.*?[\)])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@expand(\([^)]*\))/\${BF3_\1[@]}/g"
        };
        function transpile_varRef () 
        { 
            local source="$1";
            echo -e "$source" | sed "s/@ref(\([^)]*\)->\([^)]*\))/\$(local __ref=\"BF3_\1_VARS\2\"; echo \"\${!__ref}\"; unset __ref;)/g"
        };
        function transpile_globals () 
        { 
            local source="$1";
            echo -e "$source" | sed "s/@globals\[\([^]]*\)\]/\${globals['\1']}/g"
        };
        local transpiled;
        transpiled=$(echo -e "${wrapped}"             | sed "s/@this\.super\./${superNspace}._super./g"             | sed "s/@this\./${baseNamespace}./g"             | sed "s/@this:/${baseNamespace}:/g"             | sed "s/@params\[\([^]]*\)\]=/params['\1']=/g"             | sed "s/@params\[\([^]]*\)\]/\${params['\1']}/g"             | sed "s/@=>\*params/\"${baseNamespace}.\${FUNCNAME[0]##*.}::args\"; local -A params; local -a unknown; parameters.load --namespace \"${baseNamespace}.\${FUNCNAME[0]##*.}\" --ignore-unkown true --args \"\$@\"\n/"             | sed "s/@=>params/\"${baseNamespace}.\${FUNCNAME[0]##*.}::args\"; local -A params; parameters.load --namespace \"${baseNamespace}.\${FUNCNAME[0]##*.}\" --args \"\$@\"\n/"             | sed "s/@this\[\([^]]*\)\]=/${varsArrName}[\1]=/g"             | sed "s/@this\[\([^]]*\)\]/\${${varsArrName}[\1]}/g"             | sed "s/@this=>\[\([^]]*\)\]=/${varsArrName}_REAL['\1']=/g"             | sed "s/@this=>\[\([^]]*\)\]/\${${varsArrName}_REAL['\1']}/g"             | sed "s/@prop\[\([^]]*\)\]/\${${varsArrName}['\1']}/g"             | perl -pe 's%(\@get->.*?\[)% ($_x = $1) =~ s/\./_/g; $_x %eg'             | sed "s/@get->\([^[]*\)\[\([^]]*\)\]/\${BF3_\1_VARS['\2']}/g"             | perl -pe 's%(\@set->.*?\[)% ($_x = $1) =~ s/\./_/g; $_x %eg'             | sed "s/@set->\([^[]*\)\[\([^]]*\)\]=/BF3_\1_VARS['\2']=/g");
        transpiled=$(transpile_globals "${transpiled}");
        transpiled=$(transpile_realGet "${transpiled}");
        transpiled=$(transpile_realSet "${transpiled}");
        transpiled=$(transpile_arrCreate "${transpiled}");
        transpiled=$(transpile_arrGet "${transpiled}");
        transpiled=$(transpile_arrSet "${transpiled}");
        transpiled=$(transpile_arrToStr "${transpiled}");
        transpiled=$(transpile_assocCreate "${transpiled}");
        transpiled=$(transpile_assocKeys "${transpiled}");
        transpiled=$(transpile_varRef "${transpiled}");
        transpiled=$(transpile_arrAdd "${transpiled}");
        transpiled=$(transpile_arrExpand "${transpiled}");
        unset transpile_globals;
        unset transpile_realSet;
        unset transpile_realGet;
        unset transpile_arrCreate;
        unset transpile_arrGet;
        unset transpile_arrSet;
        unset transpile_arrToStr;
        unset transpile_assocCreate;
        unset transpile_assocKeys;
        unset transpile_varRef;
        unset transpile_arrAdd;
        unset transpile_arrExpand;
        local outputPath=$(mktemp);
        echo "$transpiled" > "${outputPath}";
        local syntaxCheck=$(bash -c 'source  '""${outputPath}""' 2>&1');
        if [ "${syntaxCheck}" != '' ]; then
            echo "SYNTAX ERROR:";
            echo "${syntaxCheck}";
            echo "------------- Transpiler Output -------------";
            cat "${outputPath}" | awk '{ print NR": "$0}';
            import.stackTrace;
            echo "---------------------";
            echo "Original source at: ${sourceFile}";
            return 1;
        fi;
        local formattedCode=$(bash -c 'source  '""${outputPath}""' && declare -f');
        local functionNames=$(bash -c 'source  '""${outputPath}""' && '""${nSpaceOuter}'"".init && declare -F' | awk -F'-f ' '{ print $2 }' );
        local baseNamespace="${nSpaceAlias%%._super*}";
        local nl='
';
        local extraFunctions;
        local functionName;
        while read functionName; do
            if [ "${operation}" == 'extend' ] && [ "${functionName}" != "${nSpaceOuter}.init" ] && [[ $functionName != __global::* ]]; then
                local superCall="${nSpace}._super.${originalNamespace}.${functionName}";
                extraFunctions="${extraFunctions}\n    ${nSpace}.${functionName}(){";
                extraFunctions="${extraFunctions}\n        ${nSpace}._super.${functionName} \"\$@\"";
                extraFunctions="${extraFunctions}\n    }\n";
                __import_FUNC_SOURCE["${superCall}"]="${sourceFile}";
                extraFunctions="${extraFunctions}\n    ${nSpace}._super.${functionName}(){";
                extraFunctions="${extraFunctions}\n        ${superCall} \"\$@\"";
                extraFunctions="${extraFunctions}\n    }\n";
                extraFunctions="${extraFunctions}\n    ${baseNamespace}._super.${functionName}(){";
                extraFunctions="${extraFunctions}\n        ${superCall} \"\$@\"";
                extraFunctions="${extraFunctions}\n    }\n";
                extraFunctions="${extraFunctions}\n    ${baseNamespace}.${functionName}(){";
                extraFunctions="${extraFunctions}\n        ${superCall} \"\$@\"";
                extraFunctions="${extraFunctions}\n    }\n";
                __import_FUNC_SOURCE["${nSpace}.super.${functionName}"]="${sourceFile}";
            fi;
            if string.endsWith '::precache' "$functionName"; then
                local realName;
                string.removeSuffix realName "::precache" "$functionName";
                extraFunctions="${extraFunctions}\n    ${nSpace}.${realName}(){";
                extraFunctions="${extraFunctions}\n        if import.functionExists \"\${FUNCNAME[0]}::cached\"; then\n";
                extraFunctions="${extraFunctions}\n            \"\${FUNCNAME[0]}::cached\"\n";
                extraFunctions="${extraFunctions}\n            return\n";
                extraFunctions="${extraFunctions}\n        fi\n";
                extraFunctions="${extraFunctions}\n        local result=\$(\"\${FUNCNAME[0]}::precache\" \"\$@\")";
                extraFunctions="${extraFunctions}\n        local __wrapped_function=\"\${FUNCNAME[0]}::cached() { ";
                extraFunctions="${extraFunctions}        cat << 'EOF'\n\${result}${nl}EOF${nl}";
                extraFunctions="${extraFunctions}            }\"";
                extraFunctions="${extraFunctions}\n        eval \"\${__wrapped_function}\";";
                extraFunctions="${extraFunctions}\n        \${FUNCNAME[0]}::cached";
                extraFunctions="${extraFunctions}\n    }\n";
            fi;
            __import_FUNC_SOURCE["${nSpace}.${functionName}"]="${sourceFile}";
        done < <(echo "${functionNames}");
        local nsPrefix="${baseNamespace}";
        if [ "${operation}" == 'extend' ]; then
            nsPrefix="${nSpace}._super.${originalNamespace}";
        fi;
        local namespacedCode="${formattedCode}";
        namespacedCode=$(echo "${namespacedCode}" | sed "s/\(function __global::\)\(.*\) ()/\2()/");
        namespacedCode=$(echo "${namespacedCode}" | sed "s/\(function \)\(.*\) ()/${nsPrefix}.\2()/");
        extraFunctions=$(echo -e "${extraFunctions}");
        namespacedCode=$(echo "${namespacedCode}" | head -n-1);
        namespacedCode="${namespacedCode}${nl}${extraFunctions}${nl}}";
        echo "${namespacedCode}"
    };
    function build.transpiler.logToErr () 
    { 
        local disabled
    };
    function build.transpiler.getOuterNamespace () 
    { 
        local originalNamespace="$1";
        local importOp="$2";
        local targetNs="$3";
        local nameSpaceOuter="${targetNs}";
        local namespaceAs="${originalNamespace}";
        [ "${importOp}" == 'mixin' ] && { 
            namesSpaceAs="$targetNs";
            nameSpaceOuter="${namesSpaceAs}.mixin.${originalNamespace}"
        };
        [ "${importOp}" == 'extend' ] && { 
            namesSpaceAs="$targetNs";
            nameSpaceOuter="${namesSpaceAs}.extend.${originalNamespace}"
        };
        echo "${nameSpaceOuter}"
    };
    function build.transpiler.getSuperNamespace () 
    { 
        local originalNamespace="$1";
        local importOp="$2";
        local targetNs="$3";
        local nameSpaceOuter="${targetNs}";
        local namespaceAs="${originalNamespace}";
        [ "${importOp}" == 'extend' ] && { 
            namesSpaceAs="$targetNs";
            nameSpaceOuter="${namesSpaceAs}._super.${originalNamespace}"
        };
        echo "${nameSpaceOuter}"
    }
}
build.transpiler.logToErr () 
{ 
    local disabled
}
build.transpiler.transpile () 
{ 
    local sourceFile="$1";
    local originalNamespace="$2";
    local operation="${3}";
    local nSpaceAlias="$4";
    local nSpace="${originalNamespace}";
    [ "${operation}" == 'as' ] && { 
        nSpace="$nSpaceAlias"
    };
    [ "${operation}" == 'mixin' ] && { 
        nSpace="$nSpaceAlias"
    };
    [ "${operation}" == 'extend' ] && { 
        nSpace="$nSpaceAlias"
    };
    build.transpiler.logToErr "importing ${originalNamespace} ${operation} ${nSpace}";
    local baseNamespace="${nSpace%%._super*}";
    local nsLine=$(grep -n "^@namespace" "${sourceFile}");
    local lineNum="${nsLine%%:*}";
    local varsArrName="BF3_${baseNamespace//./_}_VARS";
    local nSpaceOuter=$(build.transpiler.getOuterNamespace "${originalNamespace}" "${operation}" "${nSpace}" );
    build.transpiler.logToErr "${nSpaceOuter}";
    local superNspace=$(build.transpiler.getSuperNamespace "${originalNamespace}" "${operation}" "${nSpace}" );
    build.transpiler.logToErr "${superNsapce}";
    local funcEnd="()";
    local sourceCode=$(tail -n+"${lineNum}" "${sourceFile}");
    local wrapped=$(echo "${sourceCode}" | sed "s/@namespace//");
    local varsArrCode="if [ -z  \$${varsArrName}_REAL ]; then\n";
    varsArrCode="${varsArrCode}declare -A -g ${varsArrName}_REAL\n";
    varsArrCode="${varsArrCode}declare -g -n ${varsArrName}=${varsArrName}_REAL\n";
    varsArrCode="${varsArrCode}fi\n\n";
    varsArrCode="${varsArrCode}@this[namespace]='$baseNamespace'\n\n";
    wrapped="${varsArrCode}\n${wrapped}\n";
    wrapped="${nSpaceOuter}.init${funcEnd} {\n${wrapped}\n}";
    function transpile_realGet () 
    { 
        local source="$1";
        echo -e "$source" | perl -pe 's%(\@get=>.*?\[)% ($_x = $1) =~ s/\./_/g; $_x %eg' | sed "s/@get=>\([^[]*\)\[\([^]]*\)\]/\${BF3_\1_VARS_REAL['\2']}/g"
    };
    function transpile_realSet () 
    { 
        local source="$1";
        echo -e "$source" | perl -pe 's%(\@set=>.*?\[)% ($_x = $1) =~ s/\./_/g; $_x %eg' | sed "s/@set=>\([^[]*\)\[\([^]]*\)\]=/BF3_\1_VARS_REAL['\2']=/g"
    };
    function transpile_arrGet () 
    { 
        local source="$1";
        echo -e "$source" | perl -pe 's%(\@get\(.*?[\)|\]])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@get(\([^)]*\))/\${BF3_\1}/g"
    };
    function transpile_assocKeys () 
    { 
        local source="$1";
        echo -e "$source" | perl -pe 's%(\@keys\(.*?[\)|\]])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@keys(\([^)]*\))/\${!BF3_\1[@]}/g"
    };
    function transpile_arrCreate () 
    { 
        local source="$1";
        echo -e "$source" | perl -pe 's%(\@create\[\]\(.*?[\)|\]])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@create\[\](\([^)]*\))/\[ -z \$BF3_\1 ] \&\& declare -a -g BF3_\1/g"
    };
    function transpile_assocCreate () 
    { 
        local source="$1";
        echo -e "$source" | perl -pe 's%(\@create\{\}\(.*?[\)|\]])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@create{}(\([^)]*\))/\[ -z \$BF3_\1 ] \&\& declare -A -g BF3_\1/g"
    };
    function transpile_arrSet () 
    { 
        local source="$1";
        echo -e "$source" | perl -pe 's%(\@set\(.*?[\)|\]])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@set(\([^)]*\))=/\BF3_\1=/g"
    };
    function transpile_arrAdd () 
    { 
        local source="$1";
        echo -e "$source" | perl -pe 's%(\@add\(.*?[\)])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@add(\([^)]*\))+=/\BF3_\1+=/g"
    };
    function transpile_arrToStr () 
    { 
        local source="$1";
        echo -e "$source" | perl -pe 's%(\@arrStr\(.*?[\)])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@arrStr(\([^)]*\))/\declare -p BF3_\1/g"
    };
    function transpile_arrExpand () 
    { 
        local source="$1";
        echo -e "$source" | perl -pe 's%(\@expand\(.*?[\)])% ($_x = $1) =~ s/\./_/g; $_x %eg;' | sed "s/@expand(\([^)]*\))/\${BF3_\1[@]}/g"
    };
    function transpile_varRef () 
    { 
        local source="$1";
        echo -e "$source" | sed "s/@ref(\([^)]*\)->\([^)]*\))/\$(local __ref=\"BF3_\1_VARS\2\"; echo \"\${!__ref}\"; unset __ref;)/g"
    };
    function transpile_globals () 
    { 
        local source="$1";
        echo -e "$source" | sed "s/@globals\[\([^]]*\)\]/\${globals['\1']}/g"
    };
    local transpiled;
    transpiled=$(echo -e "${wrapped}"             | sed "s/@this\.super\./${superNspace}._super./g"             | sed "s/@this\./${baseNamespace}./g"             | sed "s/@this:/${baseNamespace}:/g"             | sed "s/@params\[\([^]]*\)\]=/params['\1']=/g"             | sed "s/@params\[\([^]]*\)\]/\${params['\1']}/g"             | sed "s/@=>\*params/\"${baseNamespace}.\${FUNCNAME[0]##*.}::args\"; local -A params; local -a unknown; parameters.load --namespace \"${baseNamespace}.\${FUNCNAME[0]##*.}\" --ignore-unkown true --args \"\$@\"\n/"             | sed "s/@=>params/\"${baseNamespace}.\${FUNCNAME[0]##*.}::args\"; local -A params; parameters.load --namespace \"${baseNamespace}.\${FUNCNAME[0]##*.}\" --args \"\$@\"\n/"             | sed "s/@this\[\([^]]*\)\]=/${varsArrName}[\1]=/g"             | sed "s/@this\[\([^]]*\)\]/\${${varsArrName}[\1]}/g"             | sed "s/@this=>\[\([^]]*\)\]=/${varsArrName}_REAL['\1']=/g"             | sed "s/@this=>\[\([^]]*\)\]/\${${varsArrName}_REAL['\1']}/g"             | sed "s/@prop\[\([^]]*\)\]/\${${varsArrName}['\1']}/g"             | perl -pe 's%(\@get->.*?\[)% ($_x = $1) =~ s/\./_/g; $_x %eg'             | sed "s/@get->\([^[]*\)\[\([^]]*\)\]/\${BF3_\1_VARS['\2']}/g"             | perl -pe 's%(\@set->.*?\[)% ($_x = $1) =~ s/\./_/g; $_x %eg'             | sed "s/@set->\([^[]*\)\[\([^]]*\)\]=/BF3_\1_VARS['\2']=/g");
    transpiled=$(transpile_globals "${transpiled}");
    transpiled=$(transpile_realGet "${transpiled}");
    transpiled=$(transpile_realSet "${transpiled}");
    transpiled=$(transpile_arrCreate "${transpiled}");
    transpiled=$(transpile_arrGet "${transpiled}");
    transpiled=$(transpile_arrSet "${transpiled}");
    transpiled=$(transpile_arrToStr "${transpiled}");
    transpiled=$(transpile_assocCreate "${transpiled}");
    transpiled=$(transpile_assocKeys "${transpiled}");
    transpiled=$(transpile_varRef "${transpiled}");
    transpiled=$(transpile_arrAdd "${transpiled}");
    transpiled=$(transpile_arrExpand "${transpiled}");
    unset transpile_globals;
    unset transpile_realSet;
    unset transpile_realGet;
    unset transpile_arrCreate;
    unset transpile_arrGet;
    unset transpile_arrSet;
    unset transpile_arrToStr;
    unset transpile_assocCreate;
    unset transpile_assocKeys;
    unset transpile_varRef;
    unset transpile_arrAdd;
    unset transpile_arrExpand;
    local outputPath=$(mktemp);
    echo "$transpiled" > "${outputPath}";
    local syntaxCheck=$(bash -c 'source  '""${outputPath}""' 2>&1');
    if [ "${syntaxCheck}" != '' ]; then
        echo "SYNTAX ERROR:";
        echo "${syntaxCheck}";
        echo "------------- Transpiler Output -------------";
        cat "${outputPath}" | awk '{ print NR": "$0}';
        import.stackTrace;
        echo "---------------------";
        echo "Original source at: ${sourceFile}";
        return 1;
    fi;
    local formattedCode=$(bash -c 'source  '""${outputPath}""' && declare -f');
    local functionNames=$(bash -c 'source  '""${outputPath}""' && '""${nSpaceOuter}'"".init && declare -F' | awk -F'-f ' '{ print $2 }' );
    local baseNamespace="${nSpaceAlias%%._super*}";
    local nl='
';
    local extraFunctions;
    local functionName;
    while read functionName; do
        if [ "${operation}" == 'extend' ] && [ "${functionName}" != "${nSpaceOuter}.init" ] && [[ $functionName != __global::* ]]; then
            local superCall="${nSpace}._super.${originalNamespace}.${functionName}";
            extraFunctions="${extraFunctions}\n    ${nSpace}.${functionName}(){";
            extraFunctions="${extraFunctions}\n        ${nSpace}._super.${functionName} \"\$@\"";
            extraFunctions="${extraFunctions}\n    }\n";
            __import_FUNC_SOURCE["${superCall}"]="${sourceFile}";
            extraFunctions="${extraFunctions}\n    ${nSpace}._super.${functionName}(){";
            extraFunctions="${extraFunctions}\n        ${superCall} \"\$@\"";
            extraFunctions="${extraFunctions}\n    }\n";
            extraFunctions="${extraFunctions}\n    ${baseNamespace}._super.${functionName}(){";
            extraFunctions="${extraFunctions}\n        ${superCall} \"\$@\"";
            extraFunctions="${extraFunctions}\n    }\n";
            extraFunctions="${extraFunctions}\n    ${baseNamespace}.${functionName}(){";
            extraFunctions="${extraFunctions}\n        ${superCall} \"\$@\"";
            extraFunctions="${extraFunctions}\n    }\n";
            __import_FUNC_SOURCE["${nSpace}.super.${functionName}"]="${sourceFile}";
        fi;
        if string.endsWith '::precache' "$functionName"; then
            local realName;
            string.removeSuffix realName "::precache" "$functionName";
            extraFunctions="${extraFunctions}\n    ${nSpace}.${realName}(){";
            extraFunctions="${extraFunctions}\n        if import.functionExists \"\${FUNCNAME[0]}::cached\"; then\n";
            extraFunctions="${extraFunctions}\n            \"\${FUNCNAME[0]}::cached\"\n";
            extraFunctions="${extraFunctions}\n            return\n";
            extraFunctions="${extraFunctions}\n        fi\n";
            extraFunctions="${extraFunctions}\n        local result=\$(\"\${FUNCNAME[0]}::precache\" \"\$@\")";
            extraFunctions="${extraFunctions}\n        local __wrapped_function=\"\${FUNCNAME[0]}::cached() { ";
            extraFunctions="${extraFunctions}        cat << 'EOF'\n\${result}${nl}EOF${nl}";
            extraFunctions="${extraFunctions}            }\"";
            extraFunctions="${extraFunctions}\n        eval \"\${__wrapped_function}\";";
            extraFunctions="${extraFunctions}\n        \${FUNCNAME[0]}::cached";
            extraFunctions="${extraFunctions}\n    }\n";
        fi;
        __import_FUNC_SOURCE["${nSpace}.${functionName}"]="${sourceFile}";
    done < <(echo "${functionNames}");
    local nsPrefix="${baseNamespace}";
    if [ "${operation}" == 'extend' ]; then
        nsPrefix="${nSpace}._super.${originalNamespace}";
    fi;
    local namespacedCode="${formattedCode}";
    namespacedCode=$(echo "${namespacedCode}" | sed "s/\(function __global::\)\(.*\) ()/\2()/");
    namespacedCode=$(echo "${namespacedCode}" | sed "s/\(function \)\(.*\) ()/${nsPrefix}.\2()/");
    extraFunctions=$(echo -e "${extraFunctions}");
    namespacedCode=$(echo "${namespacedCode}" | head -n-1);
    namespacedCode="${namespacedCode}${nl}${extraFunctions}${nl}}";
    echo "${namespacedCode}"
}
chars.init () 
{ 
    if [ -z $BF3_chars_VARS_REAL ]; then
        declare -A -g BF3_chars_VARS_REAL;
        declare -g -n BF3_chars_VARS=BF3_chars_VARS_REAL;
    fi;
    BF3_chars_VARS[namespace]='chars';
    [ -z $BF3_chars_figs ] && declare -A -g BF3_chars_figs;
    BF3_chars_figs['SKLL_N_CB']="☠";
    BF3_chars_figs['SKULL']="💀";
    BF3_chars_figs['INFO']="ℹ";
    BF3_chars_figs['INFO_ROUND']="🛈";
    BF3_chars_figs['WARN']="⚠";
    BF3_chars_figs['TICK']="🗸";
    BF3_chars_figs['FISHEYE']="◉";
    BF3_chars_figs['CIRCLE']="●";
    BF3_chars_figs['SMALL_CIRCLE']="⚬";
    BF3_chars_figs['POINT_RIGHT']="👉";
    BF3_chars_figs['CLOCK']="🕓";
    BF3_chars_figs['STAR']="★";
    BF3_chars_figs['TRI_SOLID_RIGHT']="▶";
    BF3_chars_figs['TRI_THIN_RIGHT']="▻";
    [ -z $BF3_chars_box ] && declare -A -g BF3_chars_box;
    BF3_chars_box['DBL_SE']="╔";
    BF3_chars_box['DBL_SW']="╗";
    BF3_chars_box['DBL_NW']="╝";
    BF3_chars_box['DBL_NE']="╚";
    BF3_chars_box['DBL_NSE']="╠";
    BF3_chars_box['DBL_NSW']="╣";
    BF3_chars_box['DBL_EW']="═";
    BF3_chars_box['DBL_SEW']="╦";
    BF3_chars_box['DBL_NS']="║";
    BF3_chars_box['DBL_NEW']="╩";
    BF3_chars_box['DBL_W_THIN_S']="╕";
    BF3_chars_box['DBL_E_THIN_S']="╒";
    BF3_chars_box['DBL_EW_THIN_S']="╤";
    BF3_chars_box['DBL_EW_THIN_N']="╧";
    BF3_chars_box['DBL_EW_THIN_NS']="╪";
    BF3_chars_box['ANGLE_BS']="╲";
    BF3_chars_box['ANGLE_FS']="╱";
    BF3_chars_box['THIN_SE']="┌";
    BF3_chars_box['THIN_SW']="┐";
    BF3_chars_box['THIN_NS']="│";
    BF3_chars_box['THIN_EW']="─";
    BF3_chars_box['THIN_NE']="└";
    BF3_chars_box['THIN_NW']="┘";
    BF3_chars_box['THIN_NSE']="├";
    BF3_chars_box['THIN_NSW']="┤";
    BF3_chars_box['THIN_SEW']="┬"
}
docs.help.__init () 
{ 
    docs.help.args
}
docs.help.args () 
{ 
    parameters.add --key 'showHelp' --namespace 'global' --name 'Show Help' --alias '--help' --desc 'Print help for the command.' --has-value 'm' --priority '2' --callback 'docs.help.printHelp'
}
docs.help.getCommandInfo () 
{ 
    local -A templateData;
    templateData[commandName]="${globals['commandName']}";
    templateData[buildDate]="${globals['buildDate']}";
    templateData[commandNamespace]="${globals['commandNamespace']}";
    bml.print --text "$(docs.help.resource.get 'templates/info.bml')"
}
docs.help.init () 
{ 
    if [ -z $BF3_docs_help_VARS_REAL ]; then
        declare -A -g BF3_docs_help_VARS_REAL;
        declare -g -n BF3_docs_help_VARS=BF3_docs_help_VARS_REAL;
    fi;
    BF3_docs_help_VARS[namespace]='docs.help';
    function docs.help.__init () 
    { 
        docs.help.args
    };
    function docs.help.args () 
    { 
        parameters.add --key 'showHelp' --namespace 'global' --name 'Show Help' --alias '--help' --desc 'Print help for the command.' --has-value 'm' --priority '2' --callback 'docs.help.printHelp'
    };
    function docs.help.printHelp () 
    { 
        docs.help.printCommandInfo "$@";
        docs.help.printArgs "$@";
        exit
    };
    function docs.help.printArgs () 
    { 
        local argHelp="{{b:br}}{{#b:h5}}Arguments{{/b:h5}}{{b:br}}{{b:br}}";
        local argKey;
        for argKey in "${paramKeys[@]}";
        do
            local keyPrefix="${argKey}>>";
            if [ "${globals[''isBuilding'']}" == true ] && [ "${parameterDefinitions[${keyPrefix}namespace]}" == 'run' ]; then
                continue;
            fi;
            if [ "${globals[''commandNamespace'']}.main" != "${parameterDefinitions[${keyPrefix}namespace]}" ] && [ "${parameterDefinitions[${keyPrefix}namespace]}" != 'global' ]; then
                continue;
            fi;
            local aliases="${parameterDefinitions[${keyPrefix}alias_list]}";
            local name="${parameterDefinitions[${keyPrefix}name]}";
            local desc="${parameterDefinitions[${keyPrefix}desc]}";
            local type="${parameterDefinitions[${keyPrefix}type]}";
            local typeInfo='';
            if [ "$type" == 'enum' ]; then
                local enumList="${parameterDefinitions[${keyPrefix}enum-value_list]}";
                typeInfo="{{b:in}}{{#b:d}}Must be one of the values: ${enumList}{{/b:d}}{{b:br}}";
            fi;
            argHelp="${argHelp}{{#b:b}}${aliases}{{/b:b}}, {{#b:u}}${name}{{/b:u}}{{b:br}}";
            argHelp="${argHelp}{{b:in}}{{#b:d}}${desc}{{/b:d}}{{b:br}}";
            argHelp="${argHelp}${typeInfo}";
            argHelp="${argHelp}{{b:br}}";
        done;
        bml.print --text "${argHelp}"
    };
    function docs.help.printCommandInfo () 
    { 
        docs.help.getCommandInfo "$@"
    };
    function docs.help.getCommandInfo () 
    { 
        local -A templateData;
        templateData[commandName]="${globals['commandName']}";
        templateData[buildDate]="${globals['buildDate']}";
        templateData[commandNamespace]="${globals['commandNamespace']}";
        bml.print --text "$(docs.help.resource.get 'templates/info.bml')"
    }
}
docs.help.printArgs () 
{ 
    local argHelp="{{b:br}}{{#b:h5}}Arguments{{/b:h5}}{{b:br}}{{b:br}}";
    local argKey;
    for argKey in "${paramKeys[@]}";
    do
        local keyPrefix="${argKey}>>";
        if [ "${globals[''isBuilding'']}" == true ] && [ "${parameterDefinitions[${keyPrefix}namespace]}" == 'run' ]; then
            continue;
        fi;
        if [ "${globals[''commandNamespace'']}.main" != "${parameterDefinitions[${keyPrefix}namespace]}" ] && [ "${parameterDefinitions[${keyPrefix}namespace]}" != 'global' ]; then
            continue;
        fi;
        local aliases="${parameterDefinitions[${keyPrefix}alias_list]}";
        local name="${parameterDefinitions[${keyPrefix}name]}";
        local desc="${parameterDefinitions[${keyPrefix}desc]}";
        local type="${parameterDefinitions[${keyPrefix}type]}";
        local typeInfo='';
        if [ "$type" == 'enum' ]; then
            local enumList="${parameterDefinitions[${keyPrefix}enum-value_list]}";
            typeInfo="{{b:in}}{{#b:d}}Must be one of the values: ${enumList}{{/b:d}}{{b:br}}";
        fi;
        argHelp="${argHelp}{{#b:b}}${aliases}{{/b:b}}, {{#b:u}}${name}{{/b:u}}{{b:br}}";
        argHelp="${argHelp}{{b:in}}{{#b:d}}${desc}{{/b:d}}{{b:br}}";
        argHelp="${argHelp}${typeInfo}";
        argHelp="${argHelp}{{b:br}}";
    done;
    bml.print --text "${argHelp}"
}
docs.help.printCommandInfo () 
{ 
    docs.help.getCommandInfo "$@"
}
docs.help.printHelp () 
{ 
    docs.help.printCommandInfo "$@";
    docs.help.printArgs "$@";
    exit
}
docs.help.resource.get () 
{ 
    local __file_path="$1";
    local __wrap_function="docs.help.resource.${__file_path////:-:}";
    import.functionExists "${__wrap_function}" || { 
        logger.error --message "Resource '${__file_path}' not found.";
        logger.die
    };
    $__wrap_function
}
docs.help.resource.templates:-:info.bml () 
{ 
    cat  <<'EOF'
{{#b:fmt}}

{{b:br}}

{{#b:h4}}{{templateData.commandName}}{{/b:h4}}

{{b:br}}{{b:br}}

{{#b:h5}}Info{{/b:h5}}

{{b:br}}

{{b:in}}	Built On: {{#b:d}}{{templateData.buildDate}}{{/b:d}}{{b:br}}
{{b:in}}	Module: {{#b:d}}{{templateData.commandNamespace}}{{/b:d}}{{b:br}}

{{/b:fmt}}
EOF

}
env.init () 
{ 
    if [ -z $BF3_env_VARS_REAL ]; then
        declare -A -g BF3_env_VARS_REAL;
        declare -g -n BF3_env_VARS=BF3_env_VARS_REAL;
    fi;
    BF3_env_VARS[namespace]='env';
    function env.main::args () 
    { 
        parameters.add --key 'path' --namespace 'env.main' --name 'Create' --alias '--create' --alias '-c' --desc 'Create a new bf3 environment at the specified path(defaults to .)' --has-value 'm' --required-unless 'env.main::info' --excludes 'env.main::info' --default "$(pwd)";
        parameters.add --key 'info' --namespace 'env.main' --name 'Show Info' --alias '--info' --alias '-i' --desc 'Print information about the current bf3 environment.' --required-unless 'env.main::path' --excludes 'env.main::path' --has-value 'n'
    };
    function env.main () 
    { 
        "env.${FUNCNAME[0]##*.}::args";
        local -A params;
        parameters.load --namespace "env.${FUNCNAME[0]##*.}" --args "$@";
        if [ "${params['info>>specified']}" == '1' ]; then
            env.printSummary;
        fi;
        if [ "${params['path>>specified']}" == '1' ]; then
            env.makeEnv;
        fi
    };
    function env.printSummary () 
    { 
        echo "BF3 Environment Active";
        echo "Active Environment Path: '${BF3_ACTIVE_PATH}'";
        echo "Active Environment Bootstrap: '${BF3_BOOTSTRAP}'";
        echo "Base Framework Path: '${BF3_FW_PATH}'";
        echo "Active BF3 Paths:";
        local IFS=':';
        local -a appPaths;
        read -r -a appPaths <<< "${BF3_PATH}";
        local appPath;
        for appPath in "${appPaths[@]}";
        do
            echo "    ${appPath}";
        done
    };
    function env.makeEnv () 
    { 
        logger.info --message "Creating new BF3 environment at '${params['path']}'";
        mkdir -p "${params['path']}";
        mkdir -p "${params['path']}/env";
        mkdir -p "${params['path']}/modules";
        mkdir -p "${params['path']}/install_hooks";
        mkdir -p "${params['path']}/module_libs";
        echo "$(env.getActivateFile)" > "${params['path']}/env/activate.sh";
        echo "$(env.getAddFile)" > "${params['path']}/env/add.sh";
        echo "$(env.getLibsFile)" > "${params['path']}/env/libs.sh";
        logger.info --message "To activate it run '. ${params['path']}/env/activate.sh'"
    };
    function env.getAddFile () 
    { 
        local -A templateData;
        templateData[baseFrameworkPath]="${BF3_FW_PATH}";
        mustache.compile --template "$(env.resource.get 'templates/add.sh')"
    };
    function env.getActivateFile () 
    { 
        local -A templateData;
        templateData[baseFrameworkPath]="${BF3_FW_PATH}";
        mustache.compile --template "$(env.resource.get 'templates/activate.sh')"
    };
    function env.getLibsFile () 
    { 
        local -A templateData;
        mustache.compile --template "$(env.resource.get 'templates/libs.sh')"
    }
}
env.resource.get () 
{ 
    local __file_path="$1";
    local __wrap_function="env.resource.${__file_path////:-:}";
    import.functionExists "${__wrap_function}" || { 
        logger.error --message "Resource '${__file_path}' not found.";
        logger.die
    };
    $__wrap_function
}
env.resource.templates:-:activate.sh () 
{ 
    cat  <<'EOF'
#!/usr/bin/env bash

# Source the common activation functions from the base framework environment
_CORE_SCRIPT_PATH='{{templateData.baseFrameworkPath}}'
[ -d "${_CORE_SCRIPT_PATH}" ] || {
    echo "Could not find core scripts directory at \"${_CORE_SCRIPT_PATH}\""
    exit 1
}
source "${_CORE_SCRIPT_PATH}/env/common.sh"

# If another environment is active remove all its location from the system path
if [ ! -z BF3_PATH ]; then
    export PATH=$(bf3.bootstrap.removePaths)
fi

# Set this as the current active environment
export BF3_ACTIVE_PATH="$(readlink -f $(dirname $(readlink -f ${BASH_SOURCE}))/..)"
unset BF3_PATH

# Add the fbase ramework to this environment
source "${_CORE_SCRIPT_PATH}/env/add.sh"

# Import any additional module libraries
source "$(readlink -f $(dirname $(readlink -f ${BASH_SOURCE}))/libs.sh)"

# Add this environment's commands to the system path
export PATH=$(bf3.bootstrap.addToPath "$PATH" "$(readlink -f $(dirname $(readlink -f ${BASH_SOURCE}))/..)/install_hooks")

# Add this enviroment to the BF3 path
export BF3_PATH=$(bf3.bootstrap.addToPath "$BF3_PATH" "$(readlink -f $(dirname $(readlink -f ${BASH_SOURCE}))/..)")

# This sets the path for this BF3 base framework locations
export BF3_FW_PATH="$_CORE_SCRIPT_PATH"

bf3.bootstrap.printSummary
EOF

}
env.resource.templates:-:add.sh () 
{ 
    cat  <<'EOF'

if declare -f -F 'bf3.bootstrap.addToPath' > /dev/null; then
    export BF3_PATH=$(bf3.bootstrap.addToPath "$BF3_PATH" "$(readlink -f $(dirname $(readlink -f ${BASH_SOURCE}))/..)")
    export PATH=$(bf3.bootstrap.addToPath "$PATH" "$(readlink -f $(dirname $(readlink -f ${BASH_SOURCE}))/..)/install_hooks")
else
    echo "ERROR: The function 'bf3.bootstrap.addToPath' was not found."
    echo "Make sure you have sourced 'common.sh' in the base framework environment first"
fi
EOF

}
env.resource.templates:-:libs.sh () 
{ 
    cat  <<'EOF'
# Add additional module libs here by sourcing their envronments env/add.sh file
# For example:
# if it is inside the deafult "module_libs" directory:
# source "${BF3_ACTIVE_PATH}/module_libs/some_module_lib/env/add.sh"
# or at some other path:
# source "${BF3_ACTIVE_PATH}/../some_module_lib/env/add.sh"
EOF

}
import.__init () 
{ 
    declare -a -g __import_DEPENDENCIES;
    declare -A -g __import_LOADED;
    declare -A -g __import_INITED;
    local -a __import_tmp_paths;
    declare -a -g __import_PATHS;
    declare -A -g __import_FUNC_SOURCE;
    import.loadAppPaths;
    import.require 'string';
    import.useModule 'string';
    import.require 'vendor';
    import.useModule 'vendor';
    import.require 'resource';
    import.useModule 'resource';
    import.require 'build.transpiler';
    import.useModule 'build.transpiler'
}
import.die () 
{ 
    import.stackTrace "$@";
    exit 1
}
import.extension () 
{ 
    local __extension="$1";
    local __caller_path="$(dirname $(readlink -f "${BASH_SOURCE[1]}"))";
    local __filename="${__extension##*.}.sh";
    local __extension_path="${__caller_path}/extensions/${__filename}";
    source "$__extension_path"
}
import.functionExists () 
{ 
    declare -f -F $1 > /dev/null;
    return $?
}
import.getModulePath () 
{ 
    local __returnvar=$1;
    local importNs="$2";
    local passedNs="$2";
    local nsStr="$2";
    local importerFilePath="${3}";
    local requireFile="${4:-module}";
    local oldRelativePath='';
    [ "${importNs:0:1}" == "." ] && { 
        importNs=${importNs/#./};
        oldRelativePath="$(dirname $(readlink -f "${BASH_SOURCE[2]}"))"
    };
    [[ "$importNs" == *"=="* ]] && { 
        importNs="${importNs/#*==/}"
    };
    if [[ "$importNs" == *">"* ]]; then
        requireFile="${requireFile}.${importNs##*>}";
    fi;
    local pathPiece="${nsStr//..\//<</}";
    [ "${pathPiece:0:1}" == "." ] && { 
        pathPiece="${pathPiece:1}"
    };
    pathPiece=${pathPiece%%>*};
    pathPiece="${pathPiece/==//}";
    pathPiece="${pathPiece//.//}";
    pathPiece="${pathPiece//<<\//../}";
    [[ "${pathPiece: -1}" == '/' ]] && { 
        pathPiece="${pathPiece:0:-1}"
    };
    if [ "${oldRelativePath}" != '' ]; then
        pathPiece="${oldRelativePath}/${pathPiece}";
    fi;
    local modFilePath=;
    [[ "${pathPiece:0:1}" == "/" ]] || { 
        for checkPath in "${__import_PATHS[@]}";
        do
            local fPath="${checkPath}/modules/${pathPiece}/${requireFile}.sh";
            [ -f "${fPath}" ] && { 
                modFilePath="${fPath}";
                break
            };
            fPath="${checkPath}/modules/${pathPiece}/${importNs}.sh";
            [ -f "${fPath}" ] && { 
                modFilePath="${fPath}";
                break
            };
        done
    };
    [[ "${pathPiece:0:1}" == "/" ]] && { 
        importNs="$(basename $(readlink -f "${pathPiece}"))";
        local absPath="${pathPiece}/${importNs}.sh";
        [ -f "${absPath}" ] && { 
            modFilePath="${absPath}"
        };
        absPath="${pathPiece}/${requireFile}.sh";
        [ -f "${absPath}" ] && { 
            modFilePath="${absPath}"
        };
        absPath="${pathPiece}.sh";
        [ -f "${absPath}" ] && { 
            modFilePath="${absPath}"
        }
    };
    [ -f "${modFilePath}" ] || { 
        import.die "Could not load namespace '${importNs}' file not found at '${modFilePath}'"
    };
    if [[ -n "$__returnvar" ]]; then
        eval $__returnvar="$(echo -e '$modFilePath')";
    else
        echo "$modFilePath";
    fi
}
import.init () 
{ 
    function import.__init () 
    { 
        declare -a -g __import_DEPENDENCIES;
        declare -A -g __import_LOADED;
        declare -A -g __import_INITED;
        local -a __import_tmp_paths;
        declare -a -g __import_PATHS;
        declare -A -g __import_FUNC_SOURCE;
        import.loadAppPaths;
        import.require 'string';
        import.useModule 'string';
        import.require 'vendor';
        import.useModule 'vendor';
        import.require 'resource';
        import.useModule 'resource';
        import.require 'build.transpiler';
        import.useModule 'build.transpiler'
    };
    function import.require () 
    { 
        local moduleImportStr="$1";
        local importOp=${2:-file};
        local originalNamespace="${1}";
        local namesSpaceAs="${1}";
        [[ "$originalNamespace" == *"=="* ]] && { 
            originalNamespace="${originalNamespace/#*==/}"
        };
        [ "${originalNamespace:0:1}" == "." ] && { 
            originalNamespace="${originalNamespace/#./}"
        };
        namesSpaceAs="${originalNamespace}";
        local nameSpaceOuter;
        local __require_file='module';
        [ "${importOp}" == 'file' ] && { 
            __require_file="$3"
        };
        [ "${importOp}" == 'as' ] && { 
            namesSpaceAs="$3"
        };
        nameSpaceOuter="${namesSpaceAs}";
        [ "${importOp}" == 'mixin' ] && { 
            namesSpaceAs="$3";
            nameSpaceOuter="${namesSpaceAs}.mixin.${originalNamespace}"
        };
        [ "${importOp}" == 'extend' ] && { 
            namesSpaceAs="$3";
            nameSpaceOuter="${namesSpaceAs}.extend.${originalNamespace}"
        };
        if [[ -n ${__import_LOADED["${nameSpaceOuter}"]+exists} ]]; then
            return;
        fi;
        local moduleFile;
        import.getModulePath moduleFile "$moduleImportStr" "$(dirname $(readlink -f ${BASH_SOURCE[1]}))" "$__require_file";
        local nsLine=$(grep -n "^@namespace" "${moduleFile}");
        local lineNum="${nsLine%%:*}";
        [ "${lineNum}" == '' ] && { 
            source "${moduleFile}"
        };
        [ "${lineNum}" != '' ] && { 
            local fileDir=$(dirname $(readlink -f "${moduleFile}"));
            local topSourceCode;
            topSourceCode=$( import.transpilePreNamespace 				"${moduleFile}" 				"${fileDir}" 				"${lineNum}" 				"${namesSpaceAs}" 				"${originalNamespace}" 				"${importOp}");
            local namespacedCode=$(build.transpiler.transpile "${moduleFile}" "${originalNamespace}" "${importOp}" "${namesSpaceAs}");
            local finalCode=$(echo -e "#!/usr/bin/env bash\n\n# Original Source at:\n# \"${moduleFile}\"\n\n${topSourceCode}\n\n${namespacedCode}");
            echo "${finalCode}" > "/tmp/${nameSpaceOuter}.sh";
            source "/tmp/${nameSpaceOuter}.sh"
        };
        __import_DEPENDENCIES+=("${nameSpaceOuter}");
        __import_LOADED["${nameSpaceOuter}"]='1'
    };
    function import.transpilePreNamespace () 
    { 
        local moduleFile="$1";
        local fileDir="$2";
        local lineNum="$3";
        local namesSpaceAs="$4";
        local originalNamespace="$5";
        local importOp="$6";
        local baseNamespace="${namesSpaceAs%%._super*}";
        local topSourceCode=$(head -n+$((lineNum - 1)) "${moduleFile}");
        topSourceCode=$(echo "${topSourceCode}" | sed "s&@rel==&${fileDir}==&");
        topSourceCode=$(echo "${topSourceCode}" | sed "s& as '@this\.& as '${baseNamespace}.&");
        topSourceCode=$(echo "${topSourceCode}" | sed "s& as '@this& as '${baseNamespace}&");
        topSourceCode=$(echo "${topSourceCode}" | sed "s& mixin '@this\.& mixin '${namesSpaceAs}.&");
        topSourceCode=$(echo "${topSourceCode}" | sed "s& mixin '@this& mixin '${namesSpaceAs}&");
        topSourceCode=$(echo "${topSourceCode}" | sed "s& extend '@this\.& extend '${namesSpaceAs}._super.${originalNamespace}.&");
        topSourceCode=$(echo "${topSourceCode}" | sed "s& extend '@this& extend '${namesSpaceAs}._super.${originalNamespace}&");
        topSourceCode=$(echo "${topSourceCode}" | sed "s&@this\.&${baseNamespace}.&");
        topSourceCode=$(echo "${topSourceCode}" | sed "s&@this&${baseNamespace}&");
        echo "${topSourceCode}"
    };
    function import.getModulePath () 
    { 
        local __returnvar=$1;
        local importNs="$2";
        local passedNs="$2";
        local nsStr="$2";
        local importerFilePath="${3}";
        local requireFile="${4:-module}";
        local oldRelativePath='';
        [ "${importNs:0:1}" == "." ] && { 
            importNs=${importNs/#./};
            oldRelativePath="$(dirname $(readlink -f "${BASH_SOURCE[2]}"))"
        };
        [[ "$importNs" == *"=="* ]] && { 
            importNs="${importNs/#*==/}"
        };
        if [[ "$importNs" == *">"* ]]; then
            requireFile="${requireFile}.${importNs##*>}";
        fi;
        local pathPiece="${nsStr//..\//<</}";
        [ "${pathPiece:0:1}" == "." ] && { 
            pathPiece="${pathPiece:1}"
        };
        pathPiece=${pathPiece%%>*};
        pathPiece="${pathPiece/==//}";
        pathPiece="${pathPiece//.//}";
        pathPiece="${pathPiece//<<\//../}";
        [[ "${pathPiece: -1}" == '/' ]] && { 
            pathPiece="${pathPiece:0:-1}"
        };
        if [ "${oldRelativePath}" != '' ]; then
            pathPiece="${oldRelativePath}/${pathPiece}";
        fi;
        local modFilePath=;
        [[ "${pathPiece:0:1}" == "/" ]] || { 
            for checkPath in "${__import_PATHS[@]}";
            do
                local fPath="${checkPath}/modules/${pathPiece}/${requireFile}.sh";
                [ -f "${fPath}" ] && { 
                    modFilePath="${fPath}";
                    break
                };
                fPath="${checkPath}/modules/${pathPiece}/${importNs}.sh";
                [ -f "${fPath}" ] && { 
                    modFilePath="${fPath}";
                    break
                };
            done
        };
        [[ "${pathPiece:0:1}" == "/" ]] && { 
            importNs="$(basename $(readlink -f "${pathPiece}"))";
            local absPath="${pathPiece}/${importNs}.sh";
            [ -f "${absPath}" ] && { 
                modFilePath="${absPath}"
            };
            absPath="${pathPiece}/${requireFile}.sh";
            [ -f "${absPath}" ] && { 
                modFilePath="${absPath}"
            };
            absPath="${pathPiece}.sh";
            [ -f "${absPath}" ] && { 
                modFilePath="${absPath}"
            }
        };
        [ -f "${modFilePath}" ] || { 
            import.die "Could not load namespace '${importNs}' file not found at '${modFilePath}'"
        };
        if [[ -n "$__returnvar" ]]; then
            eval $__returnvar="$(echo -e '$modFilePath')";
        else
            echo "$modFilePath";
        fi
    };
    function import.initModule () 
    { 
        local __import_modName="$1";
        if ! import.functionExists "${__import_modName}.init"; then
            echo "ERROR: Could not find module '${__import_modName}' init function.";
            import.die;
        fi;
        "${__import_modName}.init";
        if import.functionExists "${__import_modName}.__init"; then
            "${__import_modName}.__init";
        fi;
        __import_INITED["${__import_modName}"]='1'
    };
    function import.useModule () 
    { 
        local __import_modName="$1";
        if [[ ! -n ${__import_INITED["${__import_modName}"]+exists} ]]; then
            import.initModule "$__import_modName";
        else
            "${__import_modName}.init";
        fi
    };
    function import.useModules () 
    { 
        local moduleName;
        for moduleName in "${__import_DEPENDENCIES[@]}";
        do
            import.useModule "${moduleName//>/_}";
        done
    };
    function import.functionExists () 
    { 
        declare -f -F $1 > /dev/null;
        return $?
    };
    function import.loadAppPaths () 
    { 
        local -a __import_tmp_paths;
        local __ifs_tmp="$IFS";
        IFS=':' read -r -a __import_tmp_paths <<< "$BF3_PATH";
        IFS="$__ifs_tmp";
        local __import_script_path="$(dirname $(readlink -f "${BASH_SOURCE}"))";
        __import_script_path="$(readlink -f "${__import_script_path}/..")";
        local __import_path_var;
        local -a __import_tmp_paths_clean;
        local __import_include_current_path=1;
        for __import_path_var in "${__import_tmp_paths[@]}";
        do
            if [ "$__import_path_var" != '' ]; then
                __import_tmp_paths_clean+=("$__import_path_var");
            fi;
            if [ "$__import_path_var" == "$__import_script_path" ]; then
                __import_include_current_path=0;
            fi;
        done;
        if [ $__import_include_current_path -eq 1 ]; then
            __import_tmp_paths_clean+=("$__import_script_path");
        fi;
        local __import_path_count=${#__import_tmp_paths_clean[@]};
        let __import_path_count=__import_path_count=0;
        for __import_path_var in "${__import_tmp_paths_clean[@]}";
        do
            __import_PATHS["${__import_path_count}"]="$__import_path_var";
            let __import_path_count=__import_path_count+1;
        done
    };
    function import.extension () 
    { 
        local __extension="$1";
        local __caller_path="$(dirname $(readlink -f "${BASH_SOURCE[1]}"))";
        local __filename="${__extension##*.}.sh";
        local __extension_path="${__caller_path}/extensions/${__filename}";
        source "$__extension_path"
    };
    function import.useExtension () 
    { 
        local __extension_namespace="$1";
        "${__extension_namespace}.init";
        if import.functionExists "${__extension_namespace}.__init"; then
            "${__extension_namespace}.__init";
        fi
    };
    function import.stackTrace () 
    { 
        echo "$1";
        echo "-------------- Stack Trace -----------------";
        local frame=0;
        while caller $frame; do
            ((frame++));
        done;
        echo "$*"
    };
    function import.die () 
    { 
        import.stackTrace "$@";
        exit 1
    };
    return $?
}
import.initModule () 
{ 
    local __import_modName="$1";
    if ! import.functionExists "${__import_modName}.init"; then
        echo "ERROR: Could not find module '${__import_modName}' init function.";
        import.die;
    fi;
    "${__import_modName}.init";
    if import.functionExists "${__import_modName}.__init"; then
        "${__import_modName}.__init";
    fi;
    __import_INITED["${__import_modName}"]='1'
}
import.loadAppPaths () 
{ 
    local -a __import_tmp_paths;
    local __ifs_tmp="$IFS";
    IFS=':' read -r -a __import_tmp_paths <<< "$BF3_PATH";
    IFS="$__ifs_tmp";
    local __import_script_path="$(dirname $(readlink -f "${BASH_SOURCE}"))";
    __import_script_path="$(readlink -f "${__import_script_path}/..")";
    local __import_path_var;
    local -a __import_tmp_paths_clean;
    local __import_include_current_path=1;
    for __import_path_var in "${__import_tmp_paths[@]}";
    do
        if [ "$__import_path_var" != '' ]; then
            __import_tmp_paths_clean+=("$__import_path_var");
        fi;
        if [ "$__import_path_var" == "$__import_script_path" ]; then
            __import_include_current_path=0;
        fi;
    done;
    if [ $__import_include_current_path -eq 1 ]; then
        __import_tmp_paths_clean+=("$__import_script_path");
    fi;
    local __import_path_count=${#__import_tmp_paths_clean[@]};
    let __import_path_count=__import_path_count=0;
    for __import_path_var in "${__import_tmp_paths_clean[@]}";
    do
        __import_PATHS["${__import_path_count}"]="$__import_path_var";
        let __import_path_count=__import_path_count+1;
    done
}
import.require () 
{ 
    local moduleImportStr="$1";
    local importOp=${2:-file};
    local originalNamespace="${1}";
    local namesSpaceAs="${1}";
    [[ "$originalNamespace" == *"=="* ]] && { 
        originalNamespace="${originalNamespace/#*==/}"
    };
    [ "${originalNamespace:0:1}" == "." ] && { 
        originalNamespace="${originalNamespace/#./}"
    };
    namesSpaceAs="${originalNamespace}";
    local nameSpaceOuter;
    local __require_file='module';
    [ "${importOp}" == 'file' ] && { 
        __require_file="$3"
    };
    [ "${importOp}" == 'as' ] && { 
        namesSpaceAs="$3"
    };
    nameSpaceOuter="${namesSpaceAs}";
    [ "${importOp}" == 'mixin' ] && { 
        namesSpaceAs="$3";
        nameSpaceOuter="${namesSpaceAs}.mixin.${originalNamespace}"
    };
    [ "${importOp}" == 'extend' ] && { 
        namesSpaceAs="$3";
        nameSpaceOuter="${namesSpaceAs}.extend.${originalNamespace}"
    };
    if [[ -n ${__import_LOADED["${nameSpaceOuter}"]+exists} ]]; then
        return;
    fi;
    local moduleFile;
    import.getModulePath moduleFile "$moduleImportStr" "$(dirname $(readlink -f ${BASH_SOURCE[1]}))" "$__require_file";
    local nsLine=$(grep -n "^@namespace" "${moduleFile}");
    local lineNum="${nsLine%%:*}";
    [ "${lineNum}" == '' ] && { 
        source "${moduleFile}"
    };
    [ "${lineNum}" != '' ] && { 
        local fileDir=$(dirname $(readlink -f "${moduleFile}"));
        local topSourceCode;
        topSourceCode=$( import.transpilePreNamespace 				"${moduleFile}" 				"${fileDir}" 				"${lineNum}" 				"${namesSpaceAs}" 				"${originalNamespace}" 				"${importOp}");
        local namespacedCode=$(build.transpiler.transpile "${moduleFile}" "${originalNamespace}" "${importOp}" "${namesSpaceAs}");
        local finalCode=$(echo -e "#!/usr/bin/env bash\n\n# Original Source at:\n# \"${moduleFile}\"\n\n${topSourceCode}\n\n${namespacedCode}");
        echo "${finalCode}" > "/tmp/${nameSpaceOuter}.sh";
        source "/tmp/${nameSpaceOuter}.sh"
    };
    __import_DEPENDENCIES+=("${nameSpaceOuter}");
    __import_LOADED["${nameSpaceOuter}"]='1'
}
import.stackTrace () 
{ 
    echo "$1";
    echo "-------------- Stack Trace -----------------";
    local frame=0;
    while caller $frame; do
        ((frame++));
    done;
    echo "$*"
}
import.transpilePreNamespace () 
{ 
    local moduleFile="$1";
    local fileDir="$2";
    local lineNum="$3";
    local namesSpaceAs="$4";
    local originalNamespace="$5";
    local importOp="$6";
    local baseNamespace="${namesSpaceAs%%._super*}";
    local topSourceCode=$(head -n+$((lineNum - 1)) "${moduleFile}");
    topSourceCode=$(echo "${topSourceCode}" | sed "s&@rel==&${fileDir}==&");
    topSourceCode=$(echo "${topSourceCode}" | sed "s& as '@this\.& as '${baseNamespace}.&");
    topSourceCode=$(echo "${topSourceCode}" | sed "s& as '@this& as '${baseNamespace}&");
    topSourceCode=$(echo "${topSourceCode}" | sed "s& mixin '@this\.& mixin '${namesSpaceAs}.&");
    topSourceCode=$(echo "${topSourceCode}" | sed "s& mixin '@this& mixin '${namesSpaceAs}&");
    topSourceCode=$(echo "${topSourceCode}" | sed "s& extend '@this\.& extend '${namesSpaceAs}._super.${originalNamespace}.&");
    topSourceCode=$(echo "${topSourceCode}" | sed "s& extend '@this& extend '${namesSpaceAs}._super.${originalNamespace}&");
    topSourceCode=$(echo "${topSourceCode}" | sed "s&@this\.&${baseNamespace}.&");
    topSourceCode=$(echo "${topSourceCode}" | sed "s&@this&${baseNamespace}&");
    echo "${topSourceCode}"
}
import.useExtension () 
{ 
    local __extension_namespace="$1";
    "${__extension_namespace}.init";
    if import.functionExists "${__extension_namespace}.__init"; then
        "${__extension_namespace}.__init";
    fi
}
import.useModule () 
{ 
    local __import_modName="$1";
    if [[ ! -n ${__import_INITED["${__import_modName}"]+exists} ]]; then
        import.initModule "$__import_modName";
    else
        "${__import_modName}.init";
    fi
}
import.useModules () 
{ 
    local moduleName;
    for moduleName in "${__import_DEPENDENCIES[@]}";
    do
        import.useModule "${moduleName//>/_}";
    done
}
logger.args () 
{ 
    parameters.add --key 'logLevel' --namespace 'global' --name 'Log Level' --alias '--log-level' --desc 'The level of logging to output during execution.' --default 'info' --enum-value 'debug' --enum-value 'info' --enum-value 'warning' --enum-value 'error' --type 'enum'
}
logger.beginTask () 
{ 
    local -A __params;
    __params['message']='';
    __params['title']='';
    params.get "$@";
    "${__logger_HANDLERS['console']}.beginTask" "$@" --prefix 'TASK'
}
logger.br () 
{ 
    "${__logger_HANDLERS['console']}.br" "$@"
}
logger.debug () 
{ 
    local logLevel="${globals['logLevel']}";
    if [ "${BF3_logger_VARS[${logLevel}]}" -gt "${BF3_logger_VARS[debug]}" ]; then
        return 0;
    fi;
    local -A __params;
    __params['message']='';
    params.get "$@";
    "${__logger_HANDLERS['console']}.debug" "$@" --prefix 'DEBUG'
}
logger.decorationCallback () 
{ 
    if [ "${__logger_SETTINGS['force-decor']}" != '1' ]; then
        __logger_SETTINGS['decor']="${__args_VALS['logger_decoration']}";
        logger.processStartupArgs;
    fi;
    return "$?"
}
logger.die () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    "${__logger_HANDLERS['console']}.die" "$@";
    exit 0
}
logger.endTask () 
{ 
    local -A __params;
    __params['message']='';
    __params['title']='';
    __params['success']='';
    params.get "$@";
    "${__logger_HANDLERS['console']}.endTask" "$@" --prefix 'TASK'
}
logger.error () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    "${__logger_HANDLERS['console']}.error" "$@" --prefix 'ERROR'
}
logger.forceDecoration () 
{ 
    local __force_decor="$1";
    if [ "$__force_decor" != '' ]; then
        __logger_SETTINGS['decor']="${__force_decor}";
        __logger_SETTINGS['force-decor']="1";
        logger.processStartupArgs;
    fi
}
logger.forceHidePrefix () 
{ 
    local __hide_prefix="$1";
    __logger_SETTINGS['hide-prefix']="${__hide_prefix}";
    __logger_SETTINGS['force-hide-prefix']="1";
    logger.processStartupArgs
}
logger.forceVerbose () 
{ 
    local __force="$1";
    if [ "$__force" == '0' ]; then
        __logger_SETTINGS['force-verbose']='0';
    else
        __logger_SETTINGS['force-verbose']='1';
    fi
}
logger.handlers.formatted.beginTask () 
{ 
    local -A __params;
    __params['message']='';
    __params['title']='';
    params.get "$@";
    logger.handlers.formatted.print --message "BEGIN ${__params['title']} - ${__params['message']}" --prefix 'TASK'
}
logger.handlers.formatted.br () 
{ 
    echo ""
}
logger.handlers.formatted.create () 
{ 
    local -A __params;
    params.get "$@";
    local __key="${__params['id']}>>";
    local __param;
    for __param in "${!__params[@]}";
    do
        local __p_key="${__key}${__param}";
        __logger_formatted_SETTINGS["${__p_key}"]="${__params[$__param]}";
    done
}
logger.handlers.formatted.debug () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    logger.handlers.formatted.print --message "${__params['message']}" --prefix "${BF3_logger_handlers_formatted_prefixes['DEBUG']}"
}
logger.handlers.formatted.die () 
{ 
    echo "ERROR: ${1}";
    logger.handlers.formatted.stackTrace "$@"
}
logger.handlers.formatted.endTask () 
{ 
    local -A __params;
    __params['message']='';
    __params['title']='';
    __params['success']='';
    params.get "$@";
    logger.handlers.formatted.print --message "END ${__params['title']} - ${__params['message']}" --prefix 'TASK'
}
logger.handlers.formatted.error () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    logger.handlers.formatted.print --message "${__params['message']}" --prefix "${BF3_logger_handlers_formatted_prefixes['ERROR']}"
}
logger.handlers.formatted.hr () 
{ 
    echo "${BF3_logger_handlers_formatted_theme['HR']}"
}
logger.handlers.formatted.info () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    logger.handlers.formatted.print --message "${__params['message']}" --prefix "${BF3_logger_handlers_formatted_prefixes['INFO']}"
}
logger.handlers.formatted.init () 
{ 
    if [ -z $BF3_logger_handlers_formatted_VARS_REAL ]; then
        declare -A -g BF3_logger_handlers_formatted_VARS_REAL;
        declare -g -n BF3_logger_handlers_formatted_VARS=BF3_logger_handlers_formatted_VARS_REAL;
    fi;
    BF3_logger_handlers_formatted_VARS[namespace]='logger.handlers.formatted';
    declare -A -g __logger_formatted_SETTINGS;
    __logger_formatted_SETTINGS['print_prefix']='1';
    BF3_logger_handlers_formatted_VARS[prefixSep]=': ';
    [ -z $BF3_logger_handlers_formatted_prefixes ] && declare -A -g BF3_logger_handlers_formatted_prefixes;
    BF3_logger_handlers_formatted_prefixes['INFO']="INFO${BF3_logger_handlers_formatted_VARS[prefixSep]}";
    BF3_logger_handlers_formatted_prefixes['ERROR']="ERROR${BF3_logger_handlers_formatted_VARS[prefixSep]}";
    BF3_logger_handlers_formatted_prefixes['WARNING']="WARNING${BF3_logger_handlers_formatted_VARS[prefixSep]}";
    BF3_logger_handlers_formatted_prefixes['DEBUG']="DEBUG${BF3_logger_handlers_formatted_VARS[prefixSep]}";
    [ -z $BF3_logger_handlers_formatted_theme ] && declare -A -g BF3_logger_handlers_formatted_theme;
    BF3_logger_handlers_formatted_theme['HR']="-----------------------------------------------";
    function logger.handlers.formatted.create () 
    { 
        local -A __params;
        params.get "$@";
        local __key="${__params['id']}>>";
        local __param;
        for __param in "${!__params[@]}";
        do
            local __p_key="${__key}${__param}";
            __logger_formatted_SETTINGS["${__p_key}"]="${__params[$__param]}";
        done
    };
    function logger.handlers.formatted.processStartupArgs () 
    { 
        bml.loadTheme;
        BF3_logger_handlers_formatted_prefixes['INFO']=$(bml.print --text "{{#b:info}}INFO{{/b:info}}${BF3_logger_handlers_formatted_VARS[prefixSep]}");
        BF3_logger_handlers_formatted_prefixes['ERROR']=$(bml.print --text "{{#b:danger}}ERROR{{/b:danger}}${BF3_logger_handlers_formatted_VARS[prefixSep]}");
        BF3_logger_handlers_formatted_prefixes['WARNING']=$(bml.print --text "{{#b:warning}}{{#b:icon}}warning{{/b:icon}} WARNING{{/b:warning}}${BF3_logger_handlers_formatted_VARS[prefixSep]}");
        BF3_logger_handlers_formatted_prefixes['DEBUG']=$(bml.print --text "DEBUG${BF3_logger_handlers_formatted_VARS[prefixSep]}");
        BF3_logger_handlers_formatted_theme['HR']=$(bml.print --text "{{#b:hr}}")
    };
    function logger.handlers.formatted.printCommandStart () 
    { 
        logger.handlers.formatted.print --message "Starting..." --prefix 'SCRIPT'
    };
    function logger.handlers.formatted.printCommandEnd () 
    { 
        logger.handlers.formatted.print --message "Finished" --prefix 'SCRIPT'
    };
    function logger.handlers.formatted.debug () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        logger.handlers.formatted.print --message "${__params['message']}" --prefix "${BF3_logger_handlers_formatted_prefixes['DEBUG']}"
    };
    function logger.handlers.formatted.info () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        logger.handlers.formatted.print --message "${__params['message']}" --prefix "${BF3_logger_handlers_formatted_prefixes['INFO']}"
    };
    function logger.handlers.formatted.success () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        logger.handlers.formatted.print --message "${__params['message']}" --prefix 'SUCCESS'
    };
    function logger.handlers.formatted.warning () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        logger.handlers.formatted.print --message "${__params['message']}" --prefix "${BF3_logger_handlers_formatted_prefixes['WARNING']}"
    };
    function logger.handlers.formatted.error () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        logger.handlers.formatted.print --message "${__params['message']}" --prefix "${BF3_logger_handlers_formatted_prefixes['ERROR']}"
    };
    function logger.handlers.formatted.stackTrace () 
    { 
        logger.handlers.formatted.print --message '-------------- Stack Trace -----------------' --prefix 'TRACE';
        if [ ${#FUNCNAME[@]} -gt 2 ]; then
            local endIndex=3;
            echo "Call tree:";
            local i;
            for ((i=${#FUNCNAME[@]}-2; i>${endIndex}-1; i--))
            do
                local callNum;
                local funcName="${FUNCNAME[$i]}";
                local calledBy="${FUNCNAME[$i+1]}";
                let callNum=i-1;
                echo " ${callNum}: ${calledBy} == Called ==> ${funcName}(...)";
                echo "     => ${BASH_SOURCE[$i+1]}:${BASH_LINENO[$i]}";
                if [ "${calledBy}" == '' ]; then
                    continue;
                fi;
                [ -z "${__import_FUNC_SOURCE[${calledBy}]}" ] || { 
                    echo "${__import_FUNC_SOURCE[${calledBy}]}"
                };
            done;
            logger.handlers.formatted.error "$@";
            local endFunc="${FUNCNAME[${endIndex}]}";
            echo "in function '${endFunc}'";
            [ -z "${__import_FUNC_SOURCE[${endFunc}]}" ] || { 
                echo "${__import_FUNC_SOURCE[${endFunc}]}"
            };
            [ -z "${__import_FUNC_SOURCE[${endFunc}]}" ] && { 
                echo "${BASH_SOURCE[${endIndex}]}"
            };
        fi
    };
    function logger.handlers.formatted.die () 
    { 
        echo "ERROR: ${1}";
        logger.handlers.formatted.stackTrace "$@"
    };
    function logger.handlers.formatted.beginTask () 
    { 
        local -A __params;
        __params['message']='';
        __params['title']='';
        params.get "$@";
        logger.handlers.formatted.print --message "BEGIN ${__params['title']} - ${__params['message']}" --prefix 'TASK'
    };
    function logger.handlers.formatted.endTask () 
    { 
        local -A __params;
        __params['message']='';
        __params['title']='';
        __params['success']='';
        params.get "$@";
        logger.handlers.formatted.print --message "END ${__params['title']} - ${__params['message']}" --prefix 'TASK'
    };
    function logger.handlers.formatted.step () 
    { 
        local -A __params;
        __params['message']='';
        __params['number']=0;
        __params['total']=0;
        params.get "$@";
        logger.handlers.formatted.print --message "${__params['number']}/${__params['total']} - ${__params['message']}"
    };
    function logger.handlers.formatted.printLoop () 
    { 
        local __line;
        local __is_loading='0';
        while read __line; do
            echo "$__line";
        done
    };
    function logger.handlers.formatted.print () 
    { 
        local -A __params;
        __params['message']='';
        __params['prefix']='';
        __params['no-newline']='0';
        params.get "$@";
        local __log_line="${__params['message']}";
        if [ "${__logger_formatted_SETTINGS['print_prefix']}" != '0' ]; then
            __log_line="${__params['prefix']}${__log_line}";
        fi;
        if [ "${__params['no-newline']}" == '0' ]; then
            echo -e "${__log_line}";
        else
            echo -en "${__log_line}";
        fi
    };
    function logger.handlers.formatted.hr () 
    { 
        echo "${BF3_logger_handlers_formatted_theme['HR']}"
    };
    function logger.handlers.formatted.br () 
    { 
        echo ""
    };
    function logger.handlers.formatted.supportsMarkup () 
    { 
        return 1
    }
}
logger.handlers.formatted.print () 
{ 
    local -A __params;
    __params['message']='';
    __params['prefix']='';
    __params['no-newline']='0';
    params.get "$@";
    local __log_line="${__params['message']}";
    if [ "${__logger_formatted_SETTINGS['print_prefix']}" != '0' ]; then
        __log_line="${__params['prefix']}${__log_line}";
    fi;
    if [ "${__params['no-newline']}" == '0' ]; then
        echo -e "${__log_line}";
    else
        echo -en "${__log_line}";
    fi
}
logger.handlers.formatted.printCommandEnd () 
{ 
    logger.handlers.formatted.print --message "Finished" --prefix 'SCRIPT'
}
logger.handlers.formatted.printCommandStart () 
{ 
    logger.handlers.formatted.print --message "Starting..." --prefix 'SCRIPT'
}
logger.handlers.formatted.printLoop () 
{ 
    local __line;
    local __is_loading='0';
    while read __line; do
        echo "$__line";
    done
}
logger.handlers.formatted.processStartupArgs () 
{ 
    bml.loadTheme;
    BF3_logger_handlers_formatted_prefixes['INFO']=$(bml.print --text "{{#b:info}}INFO{{/b:info}}${BF3_logger_handlers_formatted_VARS[prefixSep]}");
    BF3_logger_handlers_formatted_prefixes['ERROR']=$(bml.print --text "{{#b:danger}}ERROR{{/b:danger}}${BF3_logger_handlers_formatted_VARS[prefixSep]}");
    BF3_logger_handlers_formatted_prefixes['WARNING']=$(bml.print --text "{{#b:warning}}{{#b:icon}}warning{{/b:icon}} WARNING{{/b:warning}}${BF3_logger_handlers_formatted_VARS[prefixSep]}");
    BF3_logger_handlers_formatted_prefixes['DEBUG']=$(bml.print --text "DEBUG${BF3_logger_handlers_formatted_VARS[prefixSep]}");
    BF3_logger_handlers_formatted_theme['HR']=$(bml.print --text "{{#b:hr}}")
}
logger.handlers.formatted.stackTrace () 
{ 
    logger.handlers.formatted.print --message '-------------- Stack Trace -----------------' --prefix 'TRACE';
    if [ ${#FUNCNAME[@]} -gt 2 ]; then
        local endIndex=3;
        echo "Call tree:";
        local i;
        for ((i=${#FUNCNAME[@]}-2; i>${endIndex}-1; i--))
        do
            local callNum;
            local funcName="${FUNCNAME[$i]}";
            local calledBy="${FUNCNAME[$i+1]}";
            let callNum=i-1;
            echo " ${callNum}: ${calledBy} == Called ==> ${funcName}(...)";
            echo "     => ${BASH_SOURCE[$i+1]}:${BASH_LINENO[$i]}";
            if [ "${calledBy}" == '' ]; then
                continue;
            fi;
            [ -z "${__import_FUNC_SOURCE[${calledBy}]}" ] || { 
                echo "${__import_FUNC_SOURCE[${calledBy}]}"
            };
        done;
        logger.handlers.formatted.error "$@";
        local endFunc="${FUNCNAME[${endIndex}]}";
        echo "in function '${endFunc}'";
        [ -z "${__import_FUNC_SOURCE[${endFunc}]}" ] || { 
            echo "${__import_FUNC_SOURCE[${endFunc}]}"
        };
        [ -z "${__import_FUNC_SOURCE[${endFunc}]}" ] && { 
            echo "${BASH_SOURCE[${endIndex}]}"
        };
    fi
}
logger.handlers.formatted.step () 
{ 
    local -A __params;
    __params['message']='';
    __params['number']=0;
    __params['total']=0;
    params.get "$@";
    logger.handlers.formatted.print --message "${__params['number']}/${__params['total']} - ${__params['message']}"
}
logger.handlers.formatted.success () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    logger.handlers.formatted.print --message "${__params['message']}" --prefix 'SUCCESS'
}
logger.handlers.formatted.supportsMarkup () 
{ 
    return 1
}
logger.handlers.formatted.warning () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    logger.handlers.formatted.print --message "${__params['message']}" --prefix "${BF3_logger_handlers_formatted_prefixes['WARNING']}"
}
logger.hr () 
{ 
    "${__logger_HANDLERS['console']}.hr" "$@"
}
logger.info () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    "${__logger_HANDLERS['console']}.info" "$@" --prefix 'INFO'
}
logger.init () 
{ 
    if [ -z $BF3_logger_VARS_REAL ]; then
        declare -A -g BF3_logger_VARS_REAL;
        declare -g -n BF3_logger_VARS=BF3_logger_VARS_REAL;
    fi;
    BF3_logger_VARS[namespace]='logger';
    declare -A -g __logger_LEVEL;
    __logger_LEVEL['DEBUG']=1;
    __logger_LEVEL['INFO']=2;
    __logger_LEVEL['WARN']=3;
    __logger_LEVEL['ERROR']=4;
    __logger_LEVEL['CRIT']=5;
    BF3_logger_VARS[debug]=1;
    BF3_logger_VARS[info]=2;
    BF3_logger_VARS[warning]=3;
    BF3_logger_VARS[error]=4;
    declare -A -g __logger_SETTINGS;
    __logger_SETTINGS['VERBOSITY']=3;
    __logger_SETTINGS['WIDTH']=80;
    __logger_SETTINGS['in-loop']='0';
    __logger_SETTINGS['force-verbose']='0';
    __logger_SETTINGS['decor']='0';
    __logger_SETTINGS['force-decor']='0';
    __logger_SETTINGS['hide-prefix']='0';
    __logger_SETTINGS['force-hide-prefix']='0';
    declare -A -g __logger_HANDLERS;
    __logger_HANDLERS['console']='logger.handlers.formatted';
    function logger.args () 
    { 
        parameters.add --key 'logLevel' --namespace 'global' --name 'Log Level' --alias '--log-level' --desc 'The level of logging to output during execution.' --default 'info' --enum-value 'debug' --enum-value 'info' --enum-value 'warning' --enum-value 'error' --type 'enum'
    };
    function logger.processStartupArgs () 
    { 
        "${__logger_HANDLERS['console']}.processStartupArgs" "$@"
    };
    function logger.setConsoleLogHandler () 
    { 
        local -A __params;
        __params['namespace']='';
        __params['width']=80;
        __params['use-colour']=1;
        __params['allow-styles']=1;
        __params['use-markup']=0;
        __params['log-level']="${__logger_LEVEL['INFO']}";
        __params['verbosity']="${__logger_SETTINGS['VERBOSITY']}";
        params.get "$@";
        import.useModule "${__params['namespace']}";
        __logger_HANDLERS['console']="${__params['namespace']}";
        "${__logger_HANDLERS['console']}.create" "$@" --id 'console'
    };
    function logger.printCommandStart () 
    { 
        if [ "${__logger_SETTINGS['decor']}" -lt 1 ]; then
            "${__logger_HANDLERS['console']}.printCommandStart" "$@";
        fi
    };
    function logger.printCommandEnd () 
    { 
        if [ "${__logger_SETTINGS['decor']}" -lt 1 ]; then
            "${__logger_HANDLERS['console']}.printCommandEnd" "$@";
        fi
    };
    function logger.debug () 
    { 
        local logLevel="${globals['logLevel']}";
        if [ "${BF3_logger_VARS[${logLevel}]}" -gt "${BF3_logger_VARS[debug]}" ]; then
            return 0;
        fi;
        local -A __params;
        __params['message']='';
        params.get "$@";
        "${__logger_HANDLERS['console']}.debug" "$@" --prefix 'DEBUG'
    };
    function logger.info () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        "${__logger_HANDLERS['console']}.info" "$@" --prefix 'INFO'
    };
    function logger.success () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        "${__logger_HANDLERS['console']}.success" "$@" --prefix 'SUCCESS'
    };
    function logger.warning () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        "${__logger_HANDLERS['console']}.warning" "$@" --prefix 'WARNING'
    };
    function logger.error () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        "${__logger_HANDLERS['console']}.error" "$@" --prefix 'ERROR'
    };
    function logger.stackTrace () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        "${__logger_HANDLERS['console']}.stackTrace" "$@";
        exit 0
    };
    function logger.die () 
    { 
        local -A __params;
        __params['message']='';
        params.get "$@";
        "${__logger_HANDLERS['console']}.die" "$@";
        exit 0
    };
    function logger.beginTask () 
    { 
        local -A __params;
        __params['message']='';
        __params['title']='';
        params.get "$@";
        "${__logger_HANDLERS['console']}.beginTask" "$@" --prefix 'TASK'
    };
    function logger.endTask () 
    { 
        local -A __params;
        __params['message']='';
        __params['title']='';
        __params['success']='';
        params.get "$@";
        "${__logger_HANDLERS['console']}.endTask" "$@" --prefix 'TASK'
    };
    function logger.step () 
    { 
        local -A __params;
        __params['message']='';
        __params['number']=0;
        __params['total']=0;
        params.get "$@";
        "${__logger_HANDLERS['console']}.step" "$@" --prefix 'STEP'
    };
    function logger.printLoop () 
    { 
        "${__logger_HANDLERS['console']}.printLoop" "$@"
    };
    function logger.print () 
    { 
        local -A __params;
        __params['message']='';
        __params['prefix']='';
        params.get "$@";
        "${__logger_HANDLERS['console']}.print" "$@"
    };
    function logger.hr () 
    { 
        "${__logger_HANDLERS['console']}.hr" "$@"
    };
    function logger.br () 
    { 
        "${__logger_HANDLERS['console']}.br" "$@"
    };
    function logger.supportsMarkup () 
    { 
        "${__logger_HANDLERS['console']}.supportsMarkup" "$@";
        return "$?"
    };
    function logger.forceVerbose () 
    { 
        local __force="$1";
        if [ "$__force" == '0' ]; then
            __logger_SETTINGS['force-verbose']='0';
        else
            __logger_SETTINGS['force-verbose']='1';
        fi
    };
    function logger.forceDecoration () 
    { 
        local __force_decor="$1";
        if [ "$__force_decor" != '' ]; then
            __logger_SETTINGS['decor']="${__force_decor}";
            __logger_SETTINGS['force-decor']="1";
            logger.processStartupArgs;
        fi
    };
    function logger.decorationCallback () 
    { 
        if [ "${__logger_SETTINGS['force-decor']}" != '1' ]; then
            __logger_SETTINGS['decor']="${__args_VALS['logger_decoration']}";
            logger.processStartupArgs;
        fi;
        return "$?"
    };
    function logger.forceHidePrefix () 
    { 
        local __hide_prefix="$1";
        __logger_SETTINGS['hide-prefix']="${__hide_prefix}";
        __logger_SETTINGS['force-hide-prefix']="1";
        logger.processStartupArgs
    }
}
logger.print () 
{ 
    local -A __params;
    __params['message']='';
    __params['prefix']='';
    params.get "$@";
    "${__logger_HANDLERS['console']}.print" "$@"
}
logger.printCommandEnd () 
{ 
    if [ "${__logger_SETTINGS['decor']}" -lt 1 ]; then
        "${__logger_HANDLERS['console']}.printCommandEnd" "$@";
    fi
}
logger.printCommandStart () 
{ 
    if [ "${__logger_SETTINGS['decor']}" -lt 1 ]; then
        "${__logger_HANDLERS['console']}.printCommandStart" "$@";
    fi
}
logger.printLoop () 
{ 
    "${__logger_HANDLERS['console']}.printLoop" "$@"
}
logger.processStartupArgs () 
{ 
    "${__logger_HANDLERS['console']}.processStartupArgs" "$@"
}
logger.setConsoleLogHandler () 
{ 
    local -A __params;
    __params['namespace']='';
    __params['width']=80;
    __params['use-colour']=1;
    __params['allow-styles']=1;
    __params['use-markup']=0;
    __params['log-level']="${__logger_LEVEL['INFO']}";
    __params['verbosity']="${__logger_SETTINGS['VERBOSITY']}";
    params.get "$@";
    import.useModule "${__params['namespace']}";
    __logger_HANDLERS['console']="${__params['namespace']}";
    "${__logger_HANDLERS['console']}.create" "$@" --id 'console'
}
logger.stackTrace () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    "${__logger_HANDLERS['console']}.stackTrace" "$@";
    exit 0
}
logger.step () 
{ 
    local -A __params;
    __params['message']='';
    __params['number']=0;
    __params['total']=0;
    params.get "$@";
    "${__logger_HANDLERS['console']}.step" "$@" --prefix 'STEP'
}
logger.success () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    "${__logger_HANDLERS['console']}.success" "$@" --prefix 'SUCCESS'
}
logger.supportsMarkup () 
{ 
    "${__logger_HANDLERS['console']}.supportsMarkup" "$@";
    return "$?"
}
logger.warning () 
{ 
    local -A __params;
    __params['message']='';
    params.get "$@";
    "${__logger_HANDLERS['console']}.warning" "$@" --prefix 'WARNING'
}
mo () 
{ 
    ( local moContent;
    IFS=' 
	';
    if [[ $# -gt 0 ]]; then
        case "$1" in 
            -h | --h | --he | --hel | --help)
                moUsage "$0";
                exit 0
            ;;
        esac;
    fi;
    moGetContent moContent "$@";
    moParse "$moContent" "" true )
}
moFindEndTag () 
{ 
    local content scanned standaloneBytes tag;
    scanned="";
    moSplit content "$2" '{{' '}}';
    while [[ "${#content[@]}" -gt 1 ]]; do
        moTrimWhitespace tag "${content[1]}";
        content[1]='{{'"${content[1]}"'}}';
        case $tag in 
            '#'* | '^'*)
                scanned="${scanned}${content[0]}${content[1]}";
                moTrimWhitespace tag "${tag:1}";
                moFindEndTag content "${content[2]}" "$tag" "loop";
                scanned="${scanned}${content[0]}${content[1]}";
                content=${content[2]}
            ;;
            '/'*)
                moTrimWhitespace tag "${tag:1}";
                scanned="$scanned${content[0]}";
                if [[ "$tag" == "$3" ]]; then
                    if [[ -z "$4" ]] && moIsStandalone standaloneBytes "$scanned" "${content[2]}" true; then
                        standaloneBytes=($standaloneBytes);
                        content[1]="${scanned:${standaloneBytes[0]}}${content[1]}${content[2]:0:${standaloneBytes[1]}}";
                        scanned="${scanned:0:${standaloneBytes[0]}}";
                        content[2]="${content[2]:${standaloneBytes[1]}}";
                    fi;
                    local "$1" && moIndirectArray "$1" "$scanned" "${content[1]}" "${content[2]}";
                    return 0;
                fi;
                scanned="$scanned${content[1]}";
                content=${content[2]}
            ;;
            *)
                scanned="${scanned}${content[0]}${content[1]}";
                content=${content[2]}
            ;;
        esac;
        moSplit content "$content" '{{' '}}';
    done;
    scanned="$scanned${content[0]}";
    local "$1" && moIndirectArray "$1" "${scanned}" "" ""
}
moFindString () 
{ 
    local pos string;
    string=${2%%$3*};
    [[ "$string" == "$2" ]] && pos=-1 || pos=${#string};
    local "$1" && moIndirect "$1" $pos
}
moFullTagName () 
{ 
    if [[ -z "$2" ]] || [[ "$2" == *.* ]]; then
        local "$1" && moIndirect "$1" "$3";
    else
        local "$1" && moIndirect "$1" "${2}.${3}";
    fi
}
moGetContent () 
{ 
    local content filename target;
    target=$1;
    shift;
    if [[ "${#@}" -gt 0 ]]; then
        content="";
        for filename in "$@";
        do
            content="$content"'{{>'"$filename"'}}';
        done;
    else
        moLoadFile content /dev/stdin;
    fi;
    local "$target" && moIndirect "$target" "$content"
}
moIndentLines () 
{ 
    local content fragment len posN posR result trimmed;
    result="";
    len=$((${#3} - 1));
    content="${3:0:$len}";
    if [ -z "$2" ]; then
        local "$1" && moIndirect "$1" "$content";
        return 0;
    fi;
    moFindString posN "$content" '
';
    moFindString posR "$content" '';
    while [[ "$posN" -gt -1 ]] || [[ "$posR" -gt -1 ]]; do
        if [[ "$posN" -gt -1 ]]; then
            fragment="${content:0:$posN + 1}";
            content=${content:$posN + 1};
        else
            fragment="${content:0:$posR + 1}";
            content=${content:$posR + 1};
        fi;
        moTrimChars trimmed "$fragment" false true " " '	' '
' '';
        if [ ! -z "$trimmed" ]; then
            fragment="$2$fragment";
        fi;
        result="$result$fragment";
        moFindString posN "$content" '
';
        moFindString posR "$content" '';
    done;
    moTrimChars trimmed "$content" false true " " '	';
    if [ ! -z "$trimmed" ]; then
        content="$2$content";
    fi;
    result="$result$content";
    local "$1" && moIndirect "$1" "$result"
}
moIndirect () 
{ 
    unset -v "$1";
    printf -v "$1" '%s' "$2"
}
moIndirectArray () 
{ 
    unset -v "$1";
    eval $1=\(\"\${@:2}\"\)
}
moIsArray () 
{ 
    local moTestResult;
    moTestResult=$(declare -p "$1" 2>/dev/null) || return 1;
    [[ "${moTestResult:0:10}" == "declare -a" ]] && return 0;
    [[ "${moTestResult:0:10}" == "declare -A" ]] && return 0;
    return 1
}
moIsFunction () 
{ 
    declare -f -F $1 > /dev/null;
    return $?
}
moIsStandalone () 
{ 
    local afterTrimmed beforeTrimmed char;
    moTrimChars beforeTrimmed "$2" false true " " '	';
    moTrimChars afterTrimmed "$3" true false " " '	';
    char=$((${#beforeTrimmed} - 1));
    char=${beforeTrimmed:$char};
    if [[ "$char" != '
' ]] && [[ "$char" != '' ]]; then
        if [[ ! -z "$char" ]] || ! $4; then
            return 1;
        fi;
    fi;
    char=${afterTrimmed:0:1};
    if [[ "$char" != '
' ]] && [[ "$char" != '' ]] && [[ ! -z "$char" ]]; then
        return 2;
    fi;
    if [[ "$char" == '' ]] && [[ "${afterTrimmed:1:1}" == '
' ]]; then
        char="$char"'
';
    fi;
    local "$1" && moIndirect "$1" "$((${#beforeTrimmed})) $((${#3} + ${#char} - ${#afterTrimmed}))"
}
moJoin () 
{ 
    local joiner part result target;
    target=$1;
    joiner=$2;
    result=$3;
    shift 3;
    for part in "$@";
    do
        result="$result$joiner$part";
    done;
    local "$target" && moIndirect "$target" "$result"
}
moLoadFile () 
{ 
    local content len;
    content=$(cat $2; echo '.');
    len=$((${#content} - 1));
    content=${content:0:$len};
    local "$1" && moIndirect "$1" "$content"
}
moLoop () 
{ 
    local content context contextBase;
    content=$1;
    contextBase=$2;
    shift 2;
    while [[ "${#@}" -gt 0 ]]; do
        moFullTagName context "$contextBase" "$1";
        moParse "$content" "$context" false;
        shift;
    done
}
moParse () 
{ 
    local moBlock moContent moCurrent moIsBeginning moTag;
    moCurrent=$2;
    moIsBeginning=$3;
    moSplit moContent "$1" '{{' '}}';
    while [[ "${#moContent[@]}" -gt 1 ]]; do
        moTrimWhitespace moTag "${moContent[1]}";
        case $moTag in 
            '#'*)
                moStandaloneAllowed moContent "${moContent[@]}" $moIsBeginning;
                moTrimWhitespace moTag "${moTag:1}";
                moFindEndTag moBlock "$moContent" "$moTag";
                moFullTagName moTag "$moCurrent" "$moTag";
                if moTest "$moTag"; then
                    if moIsFunction "$moTag"; then
                        moContent=$($moTag "${moBlock[0]}");
                        moParse "$moContent" "$moCurrent" false;
                        moContent="${moBlock[2]}";
                    else
                        if moIsArray "$moTag"; then
                            eval 'moLoop "${moBlock[0]}" "$moTag" "${!'"$moTag"'[@]}"';
                        else
                            moParse "${moBlock[0]}" "$moCurrent" false;
                        fi;
                    fi;
                fi;
                moContent="${moBlock[2]}"
            ;;
            '>'*)
                moPartial moContent "${moContent[@]}" $moIsBeginning "$moCurrent"
            ;;
            '/'*)
                moStandaloneAllowed moContent "${moContent[@]}" $moIsBeginning
            ;;
            '^'*)
                moStandaloneAllowed moContent "${moContent[@]}" $moIsBeginning;
                moTrimWhitespace moTag "${moTag:1}";
                moFindEndTag moBlock "$moContent" "$moTag";
                moFullTagName moTag "$moCurrent" "$moTag";
                if ! moTest "$moTag"; then
                    moParse "${moBlock[0]}" "$moCurrent" false "$moCurrent";
                fi;
                moContent="${moBlock[2]}"
            ;;
            '!'*)
                moStandaloneAllowed moContent "${moContent[@]}" $moIsBeginning
            ;;
            .)
                moStandaloneDenied moContent "${moContent[@]}";
                moShow "$moCurrent" "$moCurrent"
            ;;
            '=')
                moStandaloneAllowed moContent "${moContent[@]}" $moIsBeginning
            ;;
            '{'*)
                moStandaloneDenied moContent "${moContent[@]}";
                moContent="${moTag:1}"'}}'"$moContent";
                moSplit moContent "$moContent" '}}}';
                moTrimWhitespace moTag "${moContent[0]}";
                moFullTagName moTag "$moCurrent" "$moTag";
                moContent=${moContent[1]};
                moShow "$moTag" "$moCurrent"
            ;;
            '&'*)
                moStandaloneDenied moContent "${moContent[@]}";
                moTrimWhitespace moTag "${moTag:1}";
                moFullTagName moTag "$moCurrent" "$moTag";
                moShow "$moTag" "$moCurrent"
            ;;
            *)
                moStandaloneDenied moContent "${moContent[@]}";
                moFullTagName moTag "$moCurrent" "$moTag";
                moShow "$moTag" "$moCurrent"
            ;;
        esac;
        moIsBeginning=false;
        moSplit moContent "$moContent" '{{' '}}';
    done;
    echo -n "${moContent[0]}"
}
moPartial () 
{ 
    local moContent moFilename moIndent moPartial moStandalone;
    if moIsStandalone moStandalone "$2" "$4" $5; then
        moStandalone=($moStandalone);
        echo -n "${2:0:${moStandalone[0]}}";
        moIndent=${2:${moStandalone[0]}};
        moContent=${4:${moStandalone[1]}};
    else
        moIndent="";
        echo -n "$2";
        moContent=$4;
    fi;
    moTrimWhitespace moFilename "${3:1}";
    ( cd "$(dirname "$moFilename")";
    moIndentLines moPartial "$moIndent" "$(
            moLoadFile moPartial "${moFilename##*/}"

            # Fix bash handling of subshells
            # The extra dot is removed in moIndentLines
            echo -n "${moPartial}."
        )";
    moParse "$moPartial" "$6" true );
    local "$1" && moIndirect "$1" "$moContent"
}
moShow () 
{ 
    local moJoined moNameParts;
    if moIsFunction "$1"; then
        CONTENT=$($1 "");
        moParse "$CONTENT" "$2" false;
        return 0;
    fi;
    moSplit moNameParts "$1" ".";
    if [[ -z "${moNameParts[1]}" ]]; then
        if moIsArray "$1"; then
            eval moJoin moJoined "," "\${$1[@]}";
            echo -n "$moJoined";
        else
            echo -n "${!1}";
        fi;
    else
        eval 'echo -n "${'"${moNameParts[0]}"'['"${moNameParts[1]%%.*}"']}"';
    fi
}
moSplit () 
{ 
    local pos result;
    result=("$2");
    moFindString pos "${result[0]}" "$3";
    if [[ "$pos" -ne -1 ]]; then
        result[1]=${result[0]:$pos + ${#3}};
        result[0]=${result[0]:0:$pos};
        if [[ ! -z "$4" ]]; then
            moFindString pos "${result[1]}" "$4";
            if [[ "$pos" -ne -1 ]]; then
                result[2]="${result[1]:$pos + ${#4}}";
                result[1]="${result[1]:0:$pos}";
            fi;
        fi;
    fi;
    local "$1" && moIndirectArray "$1" "${result[@]}"
}
moStandaloneAllowed () 
{ 
    local bytes;
    if moIsStandalone bytes "$2" "$4" $5; then
        bytes=($bytes);
        echo -n "${2:0:${bytes[0]}}";
        local "$1" && moIndirect "$1" "${4:${bytes[1]}}";
    else
        echo -n "$2";
        local "$1" && moIndirect "$1" "$4";
    fi
}
moStandaloneDenied () 
{ 
    echo -n "$2";
    local "$1" && moIndirect "$1" "$4"
}
moTest () 
{ 
    moIsFunction "$1" && return 0;
    if moIsArray "$1"; then
        eval '[[ "${#'"$1"'[@]}" -gt 0 ]]' && return 0;
    else
        [[ ! -z "${!1}" ]] && return 0;
    fi;
    return 1
}
moTrimChars () 
{ 
    local back current front last target varName;
    target=$1;
    current=$2;
    front=$3;
    back=$4;
    last="";
    shift 4;
    while [[ "$current" != "$last" ]]; do
        last=$current;
        for varName in "$@";
        do
            $front && current="${current/#$varName}";
            $back && current="${current/%$varName}";
        done;
    done;
    local "$target" && moIndirect "$target" "$current"
}
moTrimWhitespace () 
{ 
    local result;
    moTrimChars result "$2" true true '' '
' '	' " ";
    local "$1" && moIndirect "$1" "$result"
}
moUsage () 
{ 
    grep '^#/' "$1" | cut -c 4-
}
mustache.__init () 
{ 
    vendor.include.mo
}
mustache.compile () 
{ 
    local __params;
    params.get "$@";
    echo "${__params[template]}" | mo
}
mustache.init () 
{ 
    if [ -z $BF3_mustache_VARS_REAL ]; then
        declare -A -g BF3_mustache_VARS_REAL;
        declare -g -n BF3_mustache_VARS=BF3_mustache_VARS_REAL;
    fi;
    BF3_mustache_VARS[namespace]='mustache';
    function mustache.__init () 
    { 
        vendor.include.mo
    };
    function mustache.compile () 
    { 
        local __params;
        params.get "$@";
        echo "${__params[template]}" | mo
    };
    function moIsFunction () 
    { 
        declare -f -F $1 > /dev/null;
        return $?
    }
}
parameters.__init () 
{ 
    declare -A -g parameterDefinitions;
    declare -A -g paramDefaults;
    declare -A -g paramSwitches;
    declare -a -g paramKeys;
    declare -a -g paramErrors;
    declare -A -g globals;
    declare -A -g addedNameSpaces
}
parameters.add () 
{ 
    local keySep='>>';
    local -A __params;
    __params['key']=;
    __params['namespace']=;
    __params['name']='';
    __params['desc']=;
    __params['required']='0';
    __params['type']='value';
    __params['has-value']='m';
    __params['priority']='0';
    __params['callback']=;
    params.get "$@";
    local -a arrTypes=('alias' 'excludes' 'includes' 'required-unless');
    arrTypes+=('enum-value');
    local parameterNamespace="${__params['namespace']}";
    local nsKey="${parameterNamespace}::${__params['key']}";
    if [[ ! -n "${addedNameSpaces["${nsKey}"]+exists}" ]]; then
        paramKeys+=("${nsKey}");
        addedNameSpaces["${nsKey}"]=true;
    fi;
    local argPrefix="${nsKey}${keySep}";
    for paramKey in "${!__params[@]}";
    do
        if ! parameters.arrContains arrTypes[@] "${paramKey}"; then
            parameterDefinitions["${argPrefix}${paramKey}"]="${__params[$paramKey]}";
        fi;
    done;
    paramDefaults["${nsKey}"]=;
    paramDefaults["${nsKey}${keySep}specified"]=0;
    local __pargs="$@";
    local __arr_name;
    for __arr_name in "${arrTypes[@]}";
    do
        parameterDefinitions["${argPrefix}${__arr_name}_list"]="";
        parameterDefinitions["${argPrefix}${__arr_name}__count"]=0;
        local __param_key="${nsKey}";
        parameters.parseArrayTypes "$__arr_name" "$@";
    done;
    paramDefaults["${nsKey}"]="${parameterDefinitions[${argPrefix}default]}"
}
parameters.arrContains () 
{ 
    local haystack=${!1};
    local needle="$2";
    printf "%s
" ${haystack[@]} | grep -q "^$needle$"
}
parameters.die () 
{ 
    if [ "${globals['built']}" == true ]; then
        exit 1;
    fi;
    echo "-------------- Stack Trace -----------------";
    local frame=0;
    while caller $frame; do
        ((frame++));
    done;
    echo "$*";
    exit 1
}
parameters.init () 
{ 
    if [ -z $BF3_parameters_VARS_REAL ]; then
        declare -A -g BF3_parameters_VARS_REAL;
        declare -g -n BF3_parameters_VARS=BF3_parameters_VARS_REAL;
    fi;
    BF3_parameters_VARS[namespace]='parameters';
    function parameters.__init () 
    { 
        declare -A -g parameterDefinitions;
        declare -A -g paramDefaults;
        declare -A -g paramSwitches;
        declare -a -g paramKeys;
        declare -a -g paramErrors;
        declare -A -g globals;
        declare -A -g addedNameSpaces
    };
    function parameters.add () 
    { 
        local keySep='>>';
        local -A __params;
        __params['key']=;
        __params['namespace']=;
        __params['name']='';
        __params['desc']=;
        __params['required']='0';
        __params['type']='value';
        __params['has-value']='m';
        __params['priority']='0';
        __params['callback']=;
        params.get "$@";
        local -a arrTypes=('alias' 'excludes' 'includes' 'required-unless');
        arrTypes+=('enum-value');
        local parameterNamespace="${__params['namespace']}";
        local nsKey="${parameterNamespace}::${__params['key']}";
        if [[ ! -n "${addedNameSpaces["${nsKey}"]+exists}" ]]; then
            paramKeys+=("${nsKey}");
            addedNameSpaces["${nsKey}"]=true;
        fi;
        local argPrefix="${nsKey}${keySep}";
        for paramKey in "${!__params[@]}";
        do
            if ! parameters.arrContains arrTypes[@] "${paramKey}"; then
                parameterDefinitions["${argPrefix}${paramKey}"]="${__params[$paramKey]}";
            fi;
        done;
        paramDefaults["${nsKey}"]=;
        paramDefaults["${nsKey}${keySep}specified"]=0;
        local __pargs="$@";
        local __arr_name;
        for __arr_name in "${arrTypes[@]}";
        do
            parameterDefinitions["${argPrefix}${__arr_name}_list"]="";
            parameterDefinitions["${argPrefix}${__arr_name}__count"]=0;
            local __param_key="${nsKey}";
            parameters.parseArrayTypes "$__arr_name" "$@";
        done;
        paramDefaults["${nsKey}"]="${parameterDefinitions[${argPrefix}default]}"
    };
    function parameters.parseArrayTypes () 
    { 
        local varName="$1";
        shift;
        local argVar;
        local isVal=0;
        local sep='';
        local numName;
        for argVar in "${@}";
        do
            if [ $isVal -eq 1 ]; then
                isVal=0;
                if [ "$varName" == 'alias' ]; then
                    paramSwitches["${argVar}__${parameterNamespace}"]="${__param_key}";
                fi;
                parameterDefinitions["${argPrefix}${varName}_list"]="${parameterDefinitions["${argPrefix}${varName}_list"]}${sep}${argVar}";
                parameterDefinitions["${argPrefix}${numName}"]="${argVar}";
                sep=',';
            else
                if [ "${argVar}" == "--${varName}" ]; then
                    isVal=1;
                    local lenCount="${parameterDefinitions["${argPrefix}${varName}__count"]}";
                    numName="${varName}<${lenCount}>";
                    let parameterDefinitions["${argPrefix}${varName}__count"]=lenCount+1;
                fi;
            fi;
        done
    };
    function parameters.parse () 
    { 
        local -A __params;
        local -a remainder;
        __params['namespace']=;
        __params['ignore-unknown']=false;
        params.getUntil '--args' "${@}";
        local allowUnknown="${__params['ignore-unknown']}";
        local parameterNamespace="${__params['namespace']}";
        local keySep='>>';
        local __var;
        local __val_key;
        local varSwitch;
        local __is_val=0;
        for __var in "${remainder[@]}";
        do
            if [ "${__var::1}" == "-" ]; then
                __is_val=1;
                varSwitch="${__var}";
                __val_key="${__var}__${parameterNamespace}";
                if [[ ! -n "${paramSwitches["${__val_key}"]+exists}" ]]; then
                    if [ "${allowUnknown}" == false ]; then
                        paramErrors+=("Unknown argument \"${varSwitch}\"");
                    fi;
                    unknown+=("${__var}");
                fi;
                local argKey=${paramSwitches[$__val_key]};
                __spec_key="${argKey}${keySep}specified";
                paramVals["${__spec_key}"]=1;
            else
                if [ $__is_val -eq 1 ]; then
                    __is_val=0;
                    if [[ ! -n "${paramSwitches["${__val_key}"]+exists}" ]]; then
                        if [ "${allowUnknown}" == false ]; then
                            paramErrors+=("Unknown argument \"${varSwitch}\" passed a value of \"${__var}\"");
                        fi;
                        unknown+=("${__var}");
                    else
                        paramVals["${paramSwitches[$__val_key]}"]="$__var";
                    fi;
                    __val_key='';
                fi;
            fi;
            let paramsCount=paramsCount+1;
        done
    };
    function parameters.processCallbacks () 
    { 
        local keySep='>>';
        local argKey;
        for argKey in "${paramKeys[@]}";
        do
            local keyPrefix="${argKey}${keySep}";
            local argSpecified="${paramVals[${keyPrefix}specified]}";
            local argPriority="${parameterDefinitions[${keyPrefix}priority]}";
            if [ "$argPriority" == '2' ] && [ "$argSpecified" == '1' ]; then
                local argCallbabck="${parameterDefinitions[${keyPrefix}callback]}";
                if [ ! -z "$argCallbabck" ]; then
                    "$argCallbabck";
                fi;
            fi;
        done
    };
    function parameters.validate () 
    { 
        local -A __params;
        __params['namespace']=;
        __params['ignore-unknown']=false;
        params.getUntil '--args' "${@}";
        local parameterNamespace="${__params['namespace']}";
        local keySep='>>';
        local argKey;
        for argKey in "${paramKeys[@]}";
        do
            [ "${parameterDefinitions[${argKey}${keySep}namespace]}" == "${parameterNamespace}" ] && { 
                parameters.validateArg "${argKey}"
            };
        done;
        if [ "${#paramErrors[@]}" -gt 0 ]; then
            for __arg_err in "${paramErrors[@]}";
            do
                logger.error --message "$__arg_err";
            done;
            logger.hr;
            logger.info --message "To see a full list of options and more info use the '--help' argument";
            parameters.die;
        fi
    };
    function parameters.loadParams () 
    { 
        local parameterNamespace="${FUNCNAME[1]}";
        parameters.load --namespace "${parameterNamespace}" --args "$@"
    };
    function parameters.load () 
    { 
        local -A __params;
        __params['namespace']=;
        __params['ignore-unknown']=false;
        __params['skip-validation']=false;
        params.get "${@}";
        local parameterNamespace="${__params['namespace']}";
        local -A paramVals;
        for paramKey in "${!paramDefaults[@]}";
        do
            if string.startsWith "${parameterNamespace}::" "${paramKey}"; then
                paramVals["${paramKey}"]="${paramDefaults[$paramKey]}";
            fi;
        done;
        parameters.parse "$@";
        parameters.processCallbacks;
        if [ ! "${__params['skip-validation']}" == true ]; then
            parameters.validate "$@";
        fi;
        for paramValKey in "${!paramVals[@]}";
        do
            local normalised;
            string.removePrefix normalised "${parameterNamespace}::" "${paramValKey}";
            params["${normalised}"]="${paramVals[${paramValKey}]}";
        done
    };
    function parameters.die () 
    { 
        if [ "${globals['built']}" == true ]; then
            exit 1;
        fi;
        echo "-------------- Stack Trace -----------------";
        local frame=0;
        while caller $frame; do
            ((frame++));
        done;
        echo "$*";
        exit 1
    };
    function parameters.validateArg () 
    { 
        local argKey="$1";
        local keySep='>>';
        local keyPrefix="${argKey}${keySep}";
        local hasValue=${parameterDefinitions[${keyPrefix}has-value]};
        local argName="${parameterDefinitions[${keyPrefix}name]}";
        local aliasList="${parameterDefinitions[${keyPrefix}alias_list]}";
        local typeKey="${argKey}${keySep}type";
        local argType=${parameterDefinitions[${typeKey}]};
        local argSpecified="${paramVals[${keyPrefix}specified]}";
        local argRequired="${parameterDefinitions[${keyPrefix}required]}";
        local argDefault="${parameterDefinitions[${keyPrefix}default]}";
        local argPriority="${parameterDefinitions[${keyPrefix}priority]}";
        if [ "$argPriority" == '1' ] && [ "$argSpecified" == '1' ]; then
            local argCallbabck="${parameterDefinitions[${keyPrefix}callback]}";
            if [ ! -z "$argCallbabck" ]; then
                "$argCallbabck";
            fi;
        fi;
        if [ "${argSpecified}" != '1' ] && [ "${argRequired}" == '1' ]; then
            paramErrors+=("The argument \"${argName}(${aliasList})\" is required");
        fi;
        if [ "$hasValue" == 'y' ] && [ -z "${paramVals[$argKey]}" ] && [ "${argRequired}" == '1' ]; then
            paramErrors+=("The argument \"${argName}(${aliasList})\" requires a value");
        else
            if [ "$hasValue" == 'n' ] && [ ! -z "${parameterDefinitions[$argKey]}" ]; then
                paramErrors+=("The argument \"${argName}(${aliasList})\" can not have a value");
            else
                if [ "$hasValue" == 'y' ] && [ -z "${paramVals[$argKey]}" ] && [ "${argSpecified}" == '1' ]; then
                    paramErrors+=("The argument \"${argName}(${aliasList})\" requires a value");
                fi;
            fi;
        fi;
        if [ "${argSpecified}" == '1' ]; then
            local loopCount=0;
            local __arr_len="${parameterDefinitions[${keyPrefix}excludes__count]}";
            while [ $loopCount -lt $__arr_len ]; do
                local excludesKey="${parameterDefinitions[${keyPrefix}excludes<${loopCount}>]}";
                if [ "${paramVals[${excludesKey}${keySep}specified]}" == '1' ]; then
                    local excludesName="${parameterDefinitions[${excludesKey}${keySep}name]}";
                    local excludesAliases="${parameterDefinitions[${excludesKey}${keySep}alias_list]}";
                    paramErrors+=("The argument \"${argName}(${aliasList})\" can not be used with \"${excludesName}(${excludesAliases})\"");
                fi;
                let loopCount=loopCount+1;
            done;
        fi;
        if [ "${argSpecified}" == '1' ]; then
            local loopCount=0;
            local __arr_len="${parameterDefinitions[${keyPrefix}includes__count]}";
            while [ $loopCount -lt $__arr_len ]; do
                local excludesKey="${parameterDefinitions[${keyPrefix}includes<${loopCount}>]}";
                if [ "${paramVals[${excludesKey}${keySep}specified]}" == '0' ]; then
                    local excludesName="${parameterDefinitions[${excludesKey}${keySep}name]}";
                    local excludesAliases="${parameterDefinitions[${excludesKey}${keySep}alias_list]}";
                    paramErrors+=("The argument \"${excludesName}(${excludesAliases})\" must also be specified when using \"${argName}(${aliasList})\"");
                fi;
                let loopCount=loopCount+1;
            done;
        fi;
        local __arr_len="${parameterDefinitions[${keyPrefix}required-unless__count]}";
        if [ "${argSpecified}" != '1' ] && [ "$__arr_len" -gt 0 ]; then
            local loopCount=0;
            local -a __req_unless_errs;
            local invalid=1;
            while [ $loopCount -lt $__arr_len ]; do
                local excludesKey="${parameterDefinitions[${keyPrefix}required-unless<${loopCount}>]}";
                if [ "${paramVals[${excludesKey}${keySep}specified]}" != '1' ]; then
                    local excludesAliases="${parameterDefinitions[${excludesKey}${keySep}alias_list]}";
                    local excludesName="${parameterDefinitions[${excludesKey}${keySep}name]}";
                    __req_unless_errs+=("The argument \"${argName}(${aliasList})\" is required unless \"${excludesName}(${excludesAliases})\" is specified.");
                else
                    invalid=0;
                fi;
                let loopCount=loopCount+1;
            done;
            if [ "$invalid" == '1' ]; then
                for __req_unless_err in "${__req_unless_errs[@]}";
                do
                    paramErrors+=("$__req_unless_err");
                done;
            fi;
        fi;
        if [ "${argType}" == "switch" ] && [ "${argSpecified}" == '1' ]; then
            paramVals[$argKey]=1;
        fi;
        if [ "${argType}" == "file_exists" ] && [ "${argSpecified}" == '1' ] && [ ! -f "${paramVals[$argKey]}" ] && [ ! -f "$(pwd)/${paramVals[$argKey]}" ]; then
            paramErrors+=("The file \"${paramVals[$argKey]}\" specified for argument \"${argName}(${aliasList})\" could not be found.");
        fi;
        if [ "${argType}" == "dir_exists" ] && [ "${argSpecified}" == '1' ] && [ ! -d "${paramVals[$argKey]}" ]; then
            paramErrors+=("The directory \"${paramVals[$argKey]}\" specified for argument \"${argName}(${loopCountaliasList})\" could not be found.");
        fi;
        if [ "${argType}" == "enum" ] && [ "${argSpecified}" == '1' ]; then
            local __enum_count=0;
            local __arr_len="${parameterDefinitions[${keyPrefix}enum-value__count]}";
            local enumFound=0;
            while [ $__enum_count -lt $__arr_len ]; do
                local __enum_val="${parameterDefinitions[${keyPrefix}enum-value<${__enum_count}>]}";
                if [ "${__enum_val}" == "${paramVals[$argKey]}" ]; then
                    enumFound=1;
                    break;
                fi;
                let __enum_count=__enum_count+1;
            done;
            if [ "${enumFound}" == '0' ]; then
                local __enum_vals="${parameterDefinitions[${keyPrefix}enum-value_list]}";
                paramErrors+=("The argument \"${argName}(${aliasList})\" must be one of these values: \"${__enum_vals}\"");
            fi;
        fi;
        if [ "${argSpecified}" != '1' ] && [ ! -z "$argDefault" ]; then
            paramVals["$argKey"]="$argDefault";
        fi
    };
    function parameters.isSpecified () 
    { 
        local -A __params;
        __params['key']=;
        params.get "$@";
        local argKey="${__params['key']}";
        local keySep='>>';
        local keyPrefix="${argKey}${keySep}";
        if [ "${paramVals[${keyPrefix}specified]}" == '1' ]; then
            return 0;
        fi;
        return 1
    };
    function parameters.arrContains () 
    { 
        local haystack=${!1};
        local needle="$2";
        printf "%s
" ${haystack[@]} | grep -q "^$needle$"
    }
}
parameters.isSpecified () 
{ 
    local -A __params;
    __params['key']=;
    params.get "$@";
    local argKey="${__params['key']}";
    local keySep='>>';
    local keyPrefix="${argKey}${keySep}";
    if [ "${paramVals[${keyPrefix}specified]}" == '1' ]; then
        return 0;
    fi;
    return 1
}
parameters.load () 
{ 
    local -A __params;
    __params['namespace']=;
    __params['ignore-unknown']=false;
    __params['skip-validation']=false;
    params.get "${@}";
    local parameterNamespace="${__params['namespace']}";
    local -A paramVals;
    for paramKey in "${!paramDefaults[@]}";
    do
        if string.startsWith "${parameterNamespace}::" "${paramKey}"; then
            paramVals["${paramKey}"]="${paramDefaults[$paramKey]}";
        fi;
    done;
    parameters.parse "$@";
    parameters.processCallbacks;
    if [ ! "${__params['skip-validation']}" == true ]; then
        parameters.validate "$@";
    fi;
    for paramValKey in "${!paramVals[@]}";
    do
        local normalised;
        string.removePrefix normalised "${parameterNamespace}::" "${paramValKey}";
        params["${normalised}"]="${paramVals[${paramValKey}]}";
    done
}
parameters.loadParams () 
{ 
    local parameterNamespace="${FUNCNAME[1]}";
    parameters.load --namespace "${parameterNamespace}" --args "$@"
}
parameters.parse () 
{ 
    local -A __params;
    local -a remainder;
    __params['namespace']=;
    __params['ignore-unknown']=false;
    params.getUntil '--args' "${@}";
    local allowUnknown="${__params['ignore-unknown']}";
    local parameterNamespace="${__params['namespace']}";
    local keySep='>>';
    local __var;
    local __val_key;
    local varSwitch;
    local __is_val=0;
    for __var in "${remainder[@]}";
    do
        if [ "${__var::1}" == "-" ]; then
            __is_val=1;
            varSwitch="${__var}";
            __val_key="${__var}__${parameterNamespace}";
            if [[ ! -n "${paramSwitches["${__val_key}"]+exists}" ]]; then
                if [ "${allowUnknown}" == false ]; then
                    paramErrors+=("Unknown argument \"${varSwitch}\"");
                fi;
                unknown+=("${__var}");
            fi;
            local argKey=${paramSwitches[$__val_key]};
            __spec_key="${argKey}${keySep}specified";
            paramVals["${__spec_key}"]=1;
        else
            if [ $__is_val -eq 1 ]; then
                __is_val=0;
                if [[ ! -n "${paramSwitches["${__val_key}"]+exists}" ]]; then
                    if [ "${allowUnknown}" == false ]; then
                        paramErrors+=("Unknown argument \"${varSwitch}\" passed a value of \"${__var}\"");
                    fi;
                    unknown+=("${__var}");
                else
                    paramVals["${paramSwitches[$__val_key]}"]="$__var";
                fi;
                __val_key='';
            fi;
        fi;
        let paramsCount=paramsCount+1;
    done
}
parameters.parseArrayTypes () 
{ 
    local varName="$1";
    shift;
    local argVar;
    local isVal=0;
    local sep='';
    local numName;
    for argVar in "${@}";
    do
        if [ $isVal -eq 1 ]; then
            isVal=0;
            if [ "$varName" == 'alias' ]; then
                paramSwitches["${argVar}__${parameterNamespace}"]="${__param_key}";
            fi;
            parameterDefinitions["${argPrefix}${varName}_list"]="${parameterDefinitions["${argPrefix}${varName}_list"]}${sep}${argVar}";
            parameterDefinitions["${argPrefix}${numName}"]="${argVar}";
            sep=',';
        else
            if [ "${argVar}" == "--${varName}" ]; then
                isVal=1;
                local lenCount="${parameterDefinitions["${argPrefix}${varName}__count"]}";
                numName="${varName}<${lenCount}>";
                let parameterDefinitions["${argPrefix}${varName}__count"]=lenCount+1;
            fi;
        fi;
    done
}
parameters.processCallbacks () 
{ 
    local keySep='>>';
    local argKey;
    for argKey in "${paramKeys[@]}";
    do
        local keyPrefix="${argKey}${keySep}";
        local argSpecified="${paramVals[${keyPrefix}specified]}";
        local argPriority="${parameterDefinitions[${keyPrefix}priority]}";
        if [ "$argPriority" == '2' ] && [ "$argSpecified" == '1' ]; then
            local argCallbabck="${parameterDefinitions[${keyPrefix}callback]}";
            if [ ! -z "$argCallbabck" ]; then
                "$argCallbabck";
            fi;
        fi;
    done
}
parameters.validate () 
{ 
    local -A __params;
    __params['namespace']=;
    __params['ignore-unknown']=false;
    params.getUntil '--args' "${@}";
    local parameterNamespace="${__params['namespace']}";
    local keySep='>>';
    local argKey;
    for argKey in "${paramKeys[@]}";
    do
        [ "${parameterDefinitions[${argKey}${keySep}namespace]}" == "${parameterNamespace}" ] && { 
            parameters.validateArg "${argKey}"
        };
    done;
    if [ "${#paramErrors[@]}" -gt 0 ]; then
        for __arg_err in "${paramErrors[@]}";
        do
            logger.error --message "$__arg_err";
        done;
        logger.hr;
        logger.info --message "To see a full list of options and more info use the '--help' argument";
        parameters.die;
    fi
}
parameters.validateArg () 
{ 
    local argKey="$1";
    local keySep='>>';
    local keyPrefix="${argKey}${keySep}";
    local hasValue=${parameterDefinitions[${keyPrefix}has-value]};
    local argName="${parameterDefinitions[${keyPrefix}name]}";
    local aliasList="${parameterDefinitions[${keyPrefix}alias_list]}";
    local typeKey="${argKey}${keySep}type";
    local argType=${parameterDefinitions[${typeKey}]};
    local argSpecified="${paramVals[${keyPrefix}specified]}";
    local argRequired="${parameterDefinitions[${keyPrefix}required]}";
    local argDefault="${parameterDefinitions[${keyPrefix}default]}";
    local argPriority="${parameterDefinitions[${keyPrefix}priority]}";
    if [ "$argPriority" == '1' ] && [ "$argSpecified" == '1' ]; then
        local argCallbabck="${parameterDefinitions[${keyPrefix}callback]}";
        if [ ! -z "$argCallbabck" ]; then
            "$argCallbabck";
        fi;
    fi;
    if [ "${argSpecified}" != '1' ] && [ "${argRequired}" == '1' ]; then
        paramErrors+=("The argument \"${argName}(${aliasList})\" is required");
    fi;
    if [ "$hasValue" == 'y' ] && [ -z "${paramVals[$argKey]}" ] && [ "${argRequired}" == '1' ]; then
        paramErrors+=("The argument \"${argName}(${aliasList})\" requires a value");
    else
        if [ "$hasValue" == 'n' ] && [ ! -z "${parameterDefinitions[$argKey]}" ]; then
            paramErrors+=("The argument \"${argName}(${aliasList})\" can not have a value");
        else
            if [ "$hasValue" == 'y' ] && [ -z "${paramVals[$argKey]}" ] && [ "${argSpecified}" == '1' ]; then
                paramErrors+=("The argument \"${argName}(${aliasList})\" requires a value");
            fi;
        fi;
    fi;
    if [ "${argSpecified}" == '1' ]; then
        local loopCount=0;
        local __arr_len="${parameterDefinitions[${keyPrefix}excludes__count]}";
        while [ $loopCount -lt $__arr_len ]; do
            local excludesKey="${parameterDefinitions[${keyPrefix}excludes<${loopCount}>]}";
            if [ "${paramVals[${excludesKey}${keySep}specified]}" == '1' ]; then
                local excludesName="${parameterDefinitions[${excludesKey}${keySep}name]}";
                local excludesAliases="${parameterDefinitions[${excludesKey}${keySep}alias_list]}";
                paramErrors+=("The argument \"${argName}(${aliasList})\" can not be used with \"${excludesName}(${excludesAliases})\"");
            fi;
            let loopCount=loopCount+1;
        done;
    fi;
    if [ "${argSpecified}" == '1' ]; then
        local loopCount=0;
        local __arr_len="${parameterDefinitions[${keyPrefix}includes__count]}";
        while [ $loopCount -lt $__arr_len ]; do
            local excludesKey="${parameterDefinitions[${keyPrefix}includes<${loopCount}>]}";
            if [ "${paramVals[${excludesKey}${keySep}specified]}" == '0' ]; then
                local excludesName="${parameterDefinitions[${excludesKey}${keySep}name]}";
                local excludesAliases="${parameterDefinitions[${excludesKey}${keySep}alias_list]}";
                paramErrors+=("The argument \"${excludesName}(${excludesAliases})\" must also be specified when using \"${argName}(${aliasList})\"");
            fi;
            let loopCount=loopCount+1;
        done;
    fi;
    local __arr_len="${parameterDefinitions[${keyPrefix}required-unless__count]}";
    if [ "${argSpecified}" != '1' ] && [ "$__arr_len" -gt 0 ]; then
        local loopCount=0;
        local -a __req_unless_errs;
        local invalid=1;
        while [ $loopCount -lt $__arr_len ]; do
            local excludesKey="${parameterDefinitions[${keyPrefix}required-unless<${loopCount}>]}";
            if [ "${paramVals[${excludesKey}${keySep}specified]}" != '1' ]; then
                local excludesAliases="${parameterDefinitions[${excludesKey}${keySep}alias_list]}";
                local excludesName="${parameterDefinitions[${excludesKey}${keySep}name]}";
                __req_unless_errs+=("The argument \"${argName}(${aliasList})\" is required unless \"${excludesName}(${excludesAliases})\" is specified.");
            else
                invalid=0;
            fi;
            let loopCount=loopCount+1;
        done;
        if [ "$invalid" == '1' ]; then
            for __req_unless_err in "${__req_unless_errs[@]}";
            do
                paramErrors+=("$__req_unless_err");
            done;
        fi;
    fi;
    if [ "${argType}" == "switch" ] && [ "${argSpecified}" == '1' ]; then
        paramVals[$argKey]=1;
    fi;
    if [ "${argType}" == "file_exists" ] && [ "${argSpecified}" == '1' ] && [ ! -f "${paramVals[$argKey]}" ] && [ ! -f "$(pwd)/${paramVals[$argKey]}" ]; then
        paramErrors+=("The file \"${paramVals[$argKey]}\" specified for argument \"${argName}(${aliasList})\" could not be found.");
    fi;
    if [ "${argType}" == "dir_exists" ] && [ "${argSpecified}" == '1' ] && [ ! -d "${paramVals[$argKey]}" ]; then
        paramErrors+=("The directory \"${paramVals[$argKey]}\" specified for argument \"${argName}(${loopCountaliasList})\" could not be found.");
    fi;
    if [ "${argType}" == "enum" ] && [ "${argSpecified}" == '1' ]; then
        local __enum_count=0;
        local __arr_len="${parameterDefinitions[${keyPrefix}enum-value__count]}";
        local enumFound=0;
        while [ $__enum_count -lt $__arr_len ]; do
            local __enum_val="${parameterDefinitions[${keyPrefix}enum-value<${__enum_count}>]}";
            if [ "${__enum_val}" == "${paramVals[$argKey]}" ]; then
                enumFound=1;
                break;
            fi;
            let __enum_count=__enum_count+1;
        done;
        if [ "${enumFound}" == '0' ]; then
            local __enum_vals="${parameterDefinitions[${keyPrefix}enum-value_list]}";
            paramErrors+=("The argument \"${argName}(${aliasList})\" must be one of these values: \"${__enum_vals}\"");
        fi;
    fi;
    if [ "${argSpecified}" != '1' ] && [ ! -z "$argDefault" ]; then
        paramVals["$argKey"]="$argDefault";
    fi
}
params.__init () 
{ 
    import.useModule 'params_base'
}
params.get () 
{ 
    params_base.get "$@"
}
params.getUntil () 
{ 
    params_base.getUntil "$@"
}
params.init () 
{ 
    function params.__init () 
    { 
        import.useModule 'params_base'
    };
    function params.get () 
    { 
        params_base.get "$@"
    };
    function params.getUntil () 
    { 
        params_base.getUntil "$@"
    }
}
params_base.get () 
{ 
    local __params_count=0;
    local __pos_count=0;
    local __is_val=0;
    local __val_key='';
    local __var;
    for __var in "${@}";
    do
        if [ $__is_val -eq 1 ]; then
            __is_val=0;
            __params["$__val_key"]="$__var";
            __val_key='';
        else
            if [ "${__var::2}" == "--" ]; then
                __is_val=1;
                __val_key="${__var:2}";
                __params["$__val_key"]='';
            else
                __params["pos[${__pos_count}]"]="$__var";
                let __pos_count=__pos_count+1;
            fi;
        fi;
        let __params_count=__params_count+1;
    done
}
params_base.getUntil () 
{ 
    local untilVal="${1}";
    shift;
    local paramsCount=0;
    local posCount=0;
    local isVal=0;
    local valKey='';
    local argVal;
    for argVal in "${@}";
    do
        if [ $isVal -eq 1 ]; then
            isVal=0;
            __params["$valKey"]="$argVal";
            valKey='';
        else
            if [ "${argVal::2}" == "--" ]; then
                isVal=1;
                valKey="${argVal:2}";
                __params["$valKey"]='';
            else
                __params["pos[${posCount}]"]="$argVal";
                let posCount=posCount+1;
            fi;
        fi;
        let paramsCount=paramsCount+1;
        shift;
        if [ "${argVal}" == "${untilVal}" ]; then
            remainder=("${@}");
            break;
        fi;
    done
}
params_base.init () 
{ 
    function params_base.get () 
    { 
        local __params_count=0;
        local __pos_count=0;
        local __is_val=0;
        local __val_key='';
        local __var;
        for __var in "${@}";
        do
            if [ $__is_val -eq 1 ]; then
                __is_val=0;
                __params["$__val_key"]="$__var";
                __val_key='';
            else
                if [ "${__var::2}" == "--" ]; then
                    __is_val=1;
                    __val_key="${__var:2}";
                    __params["$__val_key"]='';
                else
                    __params["pos[${__pos_count}]"]="$__var";
                    let __pos_count=__pos_count+1;
                fi;
            fi;
            let __params_count=__params_count+1;
        done
    };
    function params_base.getUntil () 
    { 
        local untilVal="${1}";
        shift;
        local paramsCount=0;
        local posCount=0;
        local isVal=0;
        local valKey='';
        local argVal;
        for argVal in "${@}";
        do
            if [ $isVal -eq 1 ]; then
                isVal=0;
                __params["$valKey"]="$argVal";
                valKey='';
            else
                if [ "${argVal::2}" == "--" ]; then
                    isVal=1;
                    valKey="${argVal:2}";
                    __params["$valKey"]='';
                else
                    __params["pos[${posCount}]"]="$argVal";
                    let posCount=posCount+1;
                fi;
            fi;
            let paramsCount=paramsCount+1;
            shift;
            if [ "${argVal}" == "${untilVal}" ]; then
                remainder=("${@}");
                break;
            fi;
        done
    }
}
provision.figlet.init () 
{ 
    if [ -z $BF3_provision_figlet_VARS_REAL ]; then
        declare -A -g BF3_provision_figlet_VARS_REAL;
        declare -g -n BF3_provision_figlet_VARS=BF3_provision_figlet_VARS_REAL;
    fi;
    BF3_provision_figlet_VARS[namespace]='provision.figlet';
    function provision.figlet.require () 
    { 
        if provision.isInstalled 'figlet'; then
            return 0;
        fi;
        sudo apt-get install -y 'figlet';
        return $?
    }
}
provision.figlet.require () 
{ 
    if provision.isInstalled 'figlet'; then
        return 0;
    fi;
    sudo apt-get install -y 'figlet';
    return $?
}
provision.init () 
{ 
    if [ -z $BF3_provision_VARS_REAL ]; then
        declare -A -g BF3_provision_VARS_REAL;
        declare -g -n BF3_provision_VARS=BF3_provision_VARS_REAL;
    fi;
    BF3_provision_VARS[namespace]='provision';
    function provision.isInstalled () 
    { 
        if [ $(which "$1" | wc -l) == '0' ]; then
            logger.info --message "Command \"${1}\" is not installed" --verbosity 2;
            return 1;
        fi;
        return 0
    };
    function provision.require () 
    { 
        local itemName="$1";
        shift;
        if ! import.functionExists "provision.${itemName}.require"; then
            logger.error --message "The function 'provision.${itemName}.require' was not found,'                 + ' did you forget to import the namespace 'provision.${itemName}'?";
            return 1;
        fi;
        "provision.${itemName}.require" "$@"
    };
    function provision.isPackageInstalled () 
    { 
        if [ $(apt-cache policy "$1" | grep 'Installed: (none)' | wc -l) != '0' ]; then
            logger.info --message "Package \"${1}\" is not installed" --verbosity 2;
            return 1;
        fi;
        logger.info --message "Package \"${1}\" is already installed" --verbosity 2;
        return 0
    };
    function provision.isPpaInstalled () 
    { 
        local ppaName="${1}";
        if [ ! -d /etc/apt/sources.list.d ]; then
            grep ^ /etc/apt/sources.list /etc/apt/sources.list.d/* | grep -q "${ppaName}" && { 
                return 0
            };
        else
            grep ^ /etc/apt/sources.list | grep -q "${ppaName}" && { 
                return 0
            };
        fi;
        return 1
    }
}
provision.isInstalled () 
{ 
    if [ $(which "$1" | wc -l) == '0' ]; then
        logger.info --message "Command \"${1}\" is not installed" --verbosity 2;
        return 1;
    fi;
    return 0
}
provision.isPackageInstalled () 
{ 
    if [ $(apt-cache policy "$1" | grep 'Installed: (none)' | wc -l) != '0' ]; then
        logger.info --message "Package \"${1}\" is not installed" --verbosity 2;
        return 1;
    fi;
    logger.info --message "Package \"${1}\" is already installed" --verbosity 2;
    return 0
}
provision.isPpaInstalled () 
{ 
    local ppaName="${1}";
    if [ ! -d /etc/apt/sources.list.d ]; then
        grep ^ /etc/apt/sources.list /etc/apt/sources.list.d/* | grep -q "${ppaName}" && { 
            return 0
        };
    else
        grep ^ /etc/apt/sources.list | grep -q "${ppaName}" && { 
            return 0
        };
    fi;
    return 1
}
provision.require () 
{ 
    local itemName="$1";
    shift;
    if ! import.functionExists "provision.${itemName}.require"; then
        logger.error --message "The function 'provision.${itemName}.require' was not found,'                 + ' did you forget to import the namespace 'provision.${itemName}'?";
        return 1;
    fi;
    "provision.${itemName}.require" "$@"
}
provision.visual.graphviz.graph_easy.init () 
{ 
    if [ -z $BF3_provision_visual_graphviz_graph_easy_VARS_REAL ]; then
        declare -A -g BF3_provision_visual_graphviz_graph_easy_VARS_REAL;
        declare -g -n BF3_provision_visual_graphviz_graph_easy_VARS=BF3_provision_visual_graphviz_graph_easy_VARS_REAL;
    fi;
    BF3_provision_visual_graphviz_graph_easy_VARS[namespace]='provision.visual.graphviz.graph_easy';
    function provision.visual.graphviz.graph_easy.require () 
    { 
        provision.require 'visual.graphviz';
        if ! provision.isPackageInstalled 'cpanminus'; then
            sudo apt-get install -y 'cpanminus' || { 
                return 1
            };
        fi;
        if ! provision.isInstalled 'graph-easy'; then
            sudo cpanm Graph::Easy || { 
                return 1
            };
        fi;
        return $?
    }
}
provision.visual.graphviz.graph_easy.require () 
{ 
    provision.require 'visual.graphviz';
    if ! provision.isPackageInstalled 'cpanminus'; then
        sudo apt-get install -y 'cpanminus' || { 
            return 1
        };
    fi;
    if ! provision.isInstalled 'graph-easy'; then
        sudo cpanm Graph::Easy || { 
            return 1
        };
    fi;
    return $?
}
provision.visual.graphviz.init () 
{ 
    if [ -z $BF3_provision_visual_graphviz_VARS_REAL ]; then
        declare -A -g BF3_provision_visual_graphviz_VARS_REAL;
        declare -g -n BF3_provision_visual_graphviz_VARS=BF3_provision_visual_graphviz_VARS_REAL;
    fi;
    BF3_provision_visual_graphviz_VARS[namespace]='provision.visual.graphviz';
    function provision.visual.graphviz.require () 
    { 
        if provision.isPackageInstalled 'graphviz'; then
            return 0;
        fi;
        sudo apt-get install -y 'graphviz';
        return $?
    }
}
provision.visual.graphviz.require () 
{ 
    if provision.isPackageInstalled 'graphviz'; then
        return 0;
    fi;
    sudo apt-get install -y 'graphviz';
    return $?
}
resource.get () 
{ 
    local __file_path="$1";
    local __find='/';
    local __rep=':-:';
    local __wrap_function="resource.${__file_path//$__find/$__rep}";
    import.functionExists "${__wrap_function}" || { 
        logger.error --message "Resource '${__file_path}' not found.";
        logger.error --message "The resource function '${__wrap_function}' not found.";
        logger.error --message "Make sure the resource path exists and has been included as a resource.";
        logger.die
    };
    $__wrap_function
}
resource.includeFile () 
{ 
    local __file_path="$1";
    local __wrap_function="$2";
    local __wrapped_function;
    if [ ! -f "$__file_path" ]; then
        echo "Failed to include file \"${__file_path}\"";
        logger.die;
        return 1;
    fi;
    local nl='
';
    __wrapped_function="${__wrap_function}() {${nl}cat << 'EOF'${nl}$(cat ${__file_path})${nl}EOF${nl}}";
    eval "$(echo "${__wrapped_function}")"
}
resource.init () 
{ 
    function resource.includeFile () 
    { 
        local __file_path="$1";
        local __wrap_function="$2";
        local __wrapped_function;
        if [ ! -f "$__file_path" ]; then
            echo "Failed to include file \"${__file_path}\"";
            logger.die;
            return 1;
        fi;
        local nl='
';
        __wrapped_function="${__wrap_function}() {${nl}cat << 'EOF'${nl}$(cat ${__file_path})${nl}EOF${nl}}";
        eval "$(echo "${__wrapped_function}")"
    };
    function resource.relative () 
    { 
        local __file_path="$1";
        local __importOp="$2";
        local namespace="$3";
        local basePath=;
        local relPath=;
        [[ "$__file_path" == *"=="* ]] && { 
            basePath="${__file_path/%==*/}";
            relPath="${__file_path/#*==/}"
        };
        local fullPath="${basePath}/${relPath}";
        local __find='/';
        local __rep=':-:';
        local __wrap_function="${namespace}.resource.${relPath//$__find/$__rep}";
        local getFunction="function ${namespace}.resource.get() {${nl}";
        local nl='
';
        getFunction="${getFunction}    local __file_path=\"\$1\"${nl}";
        getFunction="${getFunction}    local __wrap_function=\"${namespace}.resource.\${__file_path////:-:}\"${nl}";
        getFunction="${getFunction}    import.functionExists \"\${__wrap_function}\" || {${nl}";
        getFunction="${getFunction}        logger.error --message \"Resource '\${__file_path}' not found.\"${nl}";
        getFunction="${getFunction}        logger.die${nl}";
        getFunction="${getFunction}    }${nl}";
        getFunction="${getFunction}    \$__wrap_function${nl}";
        getFunction="${getFunction}}${nl}";
        source <(echo "${getFunction}");
        resource.includeFile "${fullPath}" "${__wrap_function}"
    };
    function resource.get () 
    { 
        local __file_path="$1";
        local __find='/';
        local __rep=':-:';
        local __wrap_function="resource.${__file_path//$__find/$__rep}";
        import.functionExists "${__wrap_function}" || { 
            logger.error --message "Resource '${__file_path}' not found.";
            logger.error --message "The resource function '${__wrap_function}' not found.";
            logger.error --message "Make sure the resource path exists and has been included as a resource.";
            logger.die
        };
        $__wrap_function
    }
}
resource.relative () 
{ 
    local __file_path="$1";
    local __importOp="$2";
    local namespace="$3";
    local basePath=;
    local relPath=;
    [[ "$__file_path" == *"=="* ]] && { 
        basePath="${__file_path/%==*/}";
        relPath="${__file_path/#*==/}"
    };
    local fullPath="${basePath}/${relPath}";
    local __find='/';
    local __rep=':-:';
    local __wrap_function="${namespace}.resource.${relPath//$__find/$__rep}";
    local getFunction="function ${namespace}.resource.get() {${nl}";
    local nl='
';
    getFunction="${getFunction}    local __file_path=\"\$1\"${nl}";
    getFunction="${getFunction}    local __wrap_function=\"${namespace}.resource.\${__file_path////:-:}\"${nl}";
    getFunction="${getFunction}    import.functionExists \"\${__wrap_function}\" || {${nl}";
    getFunction="${getFunction}        logger.error --message \"Resource '\${__file_path}' not found.\"${nl}";
    getFunction="${getFunction}        logger.die${nl}";
    getFunction="${getFunction}    }${nl}";
    getFunction="${getFunction}    \$__wrap_function${nl}";
    getFunction="${getFunction}}${nl}";
    source <(echo "${getFunction}");
    resource.includeFile "${fullPath}" "${__wrap_function}"
}
string.contains () 
{ 
    local __needle="$1";
    local __haystack="$2";
    if [[ "$__haystack" == *"$__needle"* ]]; then
        return 0;
    else
        return 1;
    fi
}
string.countChar () 
{ 
    local __return_val=$1;
    local __needle="$2";
    local __haystack="$3";
    local __temp_str=${__haystack/${__needle}/};
    local __char_num=$(( ${#__haystack} - ${#__temp_str} ));
    eval $__return_val="$(echo -e '$__char_num')"
}
string.endsWith () 
{ 
    local __needle="$1";
    local __haystack="$2";
    local __needle_len="${#__needle}";
    local __start=$(( ${#__haystack} - ${__needle_len} ));
    if [ $__start -lt 0 ]; then
        return 1;
    fi;
    if [ "${__haystack:$__start:$__needle_len}" == "$__needle" ]; then
        return 0;
    else
        return 1;
    fi
}
string.hash () 
{ 
    cksum <<< "${1}" | cut -f 1 -d ' '
}
string.init () 
{ 
    function string.return_value () 
    { 
        local __value="$1";
        local __returnvar=$2;
        if [[ -n "$__returnvar" ]]; then
            eval $__returnvar="$(echo -e '$__value')";
        else
            echo "$__value";
        fi
    };
    function string.padding () 
    { 
        local __return=$1;
        local __pad_chars="$2";
        local __length="$3";
        if [ "$__pad_chars" == ' ' ]; then
            __pad_chars="@:space:@";
        fi;
        local __pad_str=$(echo -e "$__pad_chars"             | awk -v r="$__length" '{ for(i=0;i<r;i++) printf $1; } END { printf "\n" }');
        __pad_str="${__pad_str//@:space:@/ }";
        string.return_value "$__pad_str" $__return
    };
    function string.pad () 
    { 
        local __return=$1;
        local __in_str="$2";
        local __pad_chars="$3";
        local __length="$4";
        local __in_len=${#__in_str};
        local __to_pad;
        let __to_pad=__length-__in_len;
        if [ "$__to_pad" -gt 0 ]; then
            if [ "$__pad_chars" == ' ' ]; then
                __pad_chars="@:space:@";
            fi;
            local __pad_str=$(echo -e "$__pad_chars"                 | awk -v r="$__to_pad" '{ for(i=0;i<r;i++) printf $1; } END { printf "\n" }');
            __pad_str="${__pad_str//@:space:@/ }";
        fi;
        string.return_value "${__in_str}${__pad_str}" $__return
    };
    function string.endsWith () 
    { 
        local __needle="$1";
        local __haystack="$2";
        local __needle_len="${#__needle}";
        local __start=$(( ${#__haystack} - ${__needle_len} ));
        if [ $__start -lt 0 ]; then
            return 1;
        fi;
        if [ "${__haystack:$__start:$__needle_len}" == "$__needle" ]; then
            return 0;
        else
            return 1;
        fi
    };
    function string.startsWith () 
    { 
        local __needle="$1";
        local __haystack="$2";
        local __needle_len="${#__needle}";
        local __start=0;
        if [ $__start -lt 0 ]; then
            return 1;
        fi;
        if [ "${__haystack:$__start:$__needle_len}" == "$__needle" ]; then
            return 0;
        else
            return 1;
        fi
    };
    function string.removePrefix () 
    { 
        local __returnvar=$1;
        local __needle="$2";
        local __haystack="$3";
        local __needle_len="${#__needle}";
        local __start=0;
        if ! string.startsWith "$__needle" "$__haystack"; then
            if [[ -n "$__returnvar" ]]; then
                eval $__returnvar="$(echo -e '$__haystack')";
            else
                echo "$return_var";
            fi;
            return 1;
        else
            local __new_val=${__haystack/#$__needle/};
            if [[ -n "$__returnvar" ]]; then
                eval $__returnvar="$(echo -e '$__new_val')";
            else
                echo "$return_var";
            fi;
            return 0;
        fi
    };
    function string.removeSuffix () 
    { 
        local __returnvar="$1";
        local __needle="$2";
        local __haystack="$3";
        local __needle_len="${#__needle}";
        local __start=0;
        if ! string.endsWith "$__needle" "$__haystack"; then
            if [[ -n "$__returnvar" ]]; then
                eval $__returnvar="$(echo -e '$__haystack')";
            else
                echo "$return_var";
            fi;
            return 1;
        else
            local __new_val=${__haystack/%$__needle/};
            if [[ -n "$__returnvar" ]]; then
                eval $__returnvar="$(echo -e '$__new_val')";
            else
                echo "$return_var";
            fi;
            return 0;
        fi
    };
    function string.countChar () 
    { 
        local __return_val=$1;
        local __needle="$2";
        local __haystack="$3";
        local __temp_str=${__haystack/${__needle}/};
        local __char_num=$(( ${#__haystack} - ${#__temp_str} ));
        eval $__return_val="$(echo -e '$__char_num')"
    };
    function string.toUpper () 
    { 
        local __return_val=$1;
        local __str="$2";
        local __ret=${__str^^};
        string.return_value "$__ret" $__return_val
    };
    function string.toLower () 
    { 
        local __return_val=$1;
        local __str="$2";
        local __ret=${__str,,};
        string.return_value "$__ret" $__return_val
    };
    function string.contains () 
    { 
        local __needle="$1";
        local __haystack="$2";
        if [[ "$__haystack" == *"$__needle"* ]]; then
            return 0;
        else
            return 1;
        fi
    };
    function string.replace () 
    { 
        local __return_val=$1;
        local __needle="$2";
        local __replace="$3";
        local __haystack="$4";
        local __ret=${__haystack/$__needle/$__replace};
        string.return_value "$__ret" $__return_val
    };
    function string.trimLeft () 
    { 
        local __return_val=$1;
        local var="$2";
        var="${var#"${var%%[![:space:]]*}"}";
        string.return_value "$var" $__return_val
    };
    function string.trimRight () 
    { 
        local __return_val=$1;
        local var="$2";
        var="${var%"${var##*[![:space:]]}"}";
        string.return_value "$var" $__return_val
    };
    function string.trim () 
    { 
        local __return_val=$1;
        local var="$2";
        local __trimmed;
        string.trimLeft __trimmed "$var";
        string.trimRight __trimmed "$__trimmed";
        string.return_value "$__trimmed" $__return_val
    };
    function string.hash () 
    { 
        cksum <<< "${1}" | cut -f 1 -d ' '
    }
}
string.pad () 
{ 
    local __return=$1;
    local __in_str="$2";
    local __pad_chars="$3";
    local __length="$4";
    local __in_len=${#__in_str};
    local __to_pad;
    let __to_pad=__length-__in_len;
    if [ "$__to_pad" -gt 0 ]; then
        if [ "$__pad_chars" == ' ' ]; then
            __pad_chars="@:space:@";
        fi;
        local __pad_str=$(echo -e "$__pad_chars"                 | awk -v r="$__to_pad" '{ for(i=0;i<r;i++) printf $1; } END { printf "\n" }');
        __pad_str="${__pad_str//@:space:@/ }";
    fi;
    string.return_value "${__in_str}${__pad_str}" $__return
}
string.padding () 
{ 
    local __return=$1;
    local __pad_chars="$2";
    local __length="$3";
    if [ "$__pad_chars" == ' ' ]; then
        __pad_chars="@:space:@";
    fi;
    local __pad_str=$(echo -e "$__pad_chars"             | awk -v r="$__length" '{ for(i=0;i<r;i++) printf $1; } END { printf "\n" }');
    __pad_str="${__pad_str//@:space:@/ }";
    string.return_value "$__pad_str" $__return
}
string.removePrefix () 
{ 
    local __returnvar=$1;
    local __needle="$2";
    local __haystack="$3";
    local __needle_len="${#__needle}";
    local __start=0;
    if ! string.startsWith "$__needle" "$__haystack"; then
        if [[ -n "$__returnvar" ]]; then
            eval $__returnvar="$(echo -e '$__haystack')";
        else
            echo "$return_var";
        fi;
        return 1;
    else
        local __new_val=${__haystack/#$__needle/};
        if [[ -n "$__returnvar" ]]; then
            eval $__returnvar="$(echo -e '$__new_val')";
        else
            echo "$return_var";
        fi;
        return 0;
    fi
}
string.removeSuffix () 
{ 
    local __returnvar="$1";
    local __needle="$2";
    local __haystack="$3";
    local __needle_len="${#__needle}";
    local __start=0;
    if ! string.endsWith "$__needle" "$__haystack"; then
        if [[ -n "$__returnvar" ]]; then
            eval $__returnvar="$(echo -e '$__haystack')";
        else
            echo "$return_var";
        fi;
        return 1;
    else
        local __new_val=${__haystack/%$__needle/};
        if [[ -n "$__returnvar" ]]; then
            eval $__returnvar="$(echo -e '$__new_val')";
        else
            echo "$return_var";
        fi;
        return 0;
    fi
}
string.replace () 
{ 
    local __return_val=$1;
    local __needle="$2";
    local __replace="$3";
    local __haystack="$4";
    local __ret=${__haystack/$__needle/$__replace};
    string.return_value "$__ret" $__return_val
}
string.return_value () 
{ 
    local __value="$1";
    local __returnvar=$2;
    if [[ -n "$__returnvar" ]]; then
        eval $__returnvar="$(echo -e '$__value')";
    else
        echo "$__value";
    fi
}
string.startsWith () 
{ 
    local __needle="$1";
    local __haystack="$2";
    local __needle_len="${#__needle}";
    local __start=0;
    if [ $__start -lt 0 ]; then
        return 1;
    fi;
    if [ "${__haystack:$__start:$__needle_len}" == "$__needle" ]; then
        return 0;
    else
        return 1;
    fi
}
string.toLower () 
{ 
    local __return_val=$1;
    local __str="$2";
    local __ret=${__str,,};
    string.return_value "$__ret" $__return_val
}
string.toUpper () 
{ 
    local __return_val=$1;
    local __str="$2";
    local __ret=${__str^^};
    string.return_value "$__ret" $__return_val
}
string.trim () 
{ 
    local __return_val=$1;
    local var="$2";
    local __trimmed;
    string.trimLeft __trimmed "$var";
    string.trimRight __trimmed "$__trimmed";
    string.return_value "$__trimmed" $__return_val
}
string.trimLeft () 
{ 
    local __return_val=$1;
    local var="$2";
    var="${var#"${var%%[![:space:]]*}"}";
    string.return_value "$var" $__return_val
}
string.trimRight () 
{ 
    local __return_val=$1;
    local var="$2";
    var="${var%"${var##*[![:space:]]}"}";
    string.return_value "$var" $__return_val
}
vendor.__init () 
{ 
    import.useModule 'vendor_base'
}
vendor.getPath () 
{ 
    vendor_base.getPath "$@"
}
vendor.include.mo () 
{ 
    function mo () 
    { 
        ( local moContent;
        IFS=' 
	';
        if [[ $# -gt 0 ]]; then
            case "$1" in 
                -h | --h | --he | --hel | --help)
                    moUsage "$0";
                    exit 0
                ;;
            esac;
        fi;
        moGetContent moContent "$@";
        moParse "$moContent" "" true )
    };
    function moFindEndTag () 
    { 
        local content scanned standaloneBytes tag;
        scanned="";
        moSplit content "$2" '{{' '}}';
        while [[ "${#content[@]}" -gt 1 ]]; do
            moTrimWhitespace tag "${content[1]}";
            content[1]='{{'"${content[1]}"'}}';
            case $tag in 
                '#'* | '^'*)
                    scanned="${scanned}${content[0]}${content[1]}";
                    moTrimWhitespace tag "${tag:1}";
                    moFindEndTag content "${content[2]}" "$tag" "loop";
                    scanned="${scanned}${content[0]}${content[1]}";
                    content=${content[2]}
                ;;
                '/'*)
                    moTrimWhitespace tag "${tag:1}";
                    scanned="$scanned${content[0]}";
                    if [[ "$tag" == "$3" ]]; then
                        if [[ -z "$4" ]] && moIsStandalone standaloneBytes "$scanned" "${content[2]}" true; then
                            standaloneBytes=($standaloneBytes);
                            content[1]="${scanned:${standaloneBytes[0]}}${content[1]}${content[2]:0:${standaloneBytes[1]}}";
                            scanned="${scanned:0:${standaloneBytes[0]}}";
                            content[2]="${content[2]:${standaloneBytes[1]}}";
                        fi;
                        local "$1" && moIndirectArray "$1" "$scanned" "${content[1]}" "${content[2]}";
                        return 0;
                    fi;
                    scanned="$scanned${content[1]}";
                    content=${content[2]}
                ;;
                *)
                    scanned="${scanned}${content[0]}${content[1]}";
                    content=${content[2]}
                ;;
            esac;
            moSplit content "$content" '{{' '}}';
        done;
        scanned="$scanned${content[0]}";
        local "$1" && moIndirectArray "$1" "${scanned}" "" ""
    };
    function moFindString () 
    { 
        local pos string;
        string=${2%%$3*};
        [[ "$string" == "$2" ]] && pos=-1 || pos=${#string};
        local "$1" && moIndirect "$1" $pos
    };
    function moFullTagName () 
    { 
        if [[ -z "$2" ]] || [[ "$2" == *.* ]]; then
            local "$1" && moIndirect "$1" "$3";
        else
            local "$1" && moIndirect "$1" "${2}.${3}";
        fi
    };
    function moGetContent () 
    { 
        local content filename target;
        target=$1;
        shift;
        if [[ "${#@}" -gt 0 ]]; then
            content="";
            for filename in "$@";
            do
                content="$content"'{{>'"$filename"'}}';
            done;
        else
            moLoadFile content /dev/stdin;
        fi;
        local "$target" && moIndirect "$target" "$content"
    };
    function moIndentLines () 
    { 
        local content fragment len posN posR result trimmed;
        result="";
        len=$((${#3} - 1));
        content="${3:0:$len}";
        if [ -z "$2" ]; then
            local "$1" && moIndirect "$1" "$content";
            return 0;
        fi;
        moFindString posN "$content" '
';
        moFindString posR "$content" '';
        while [[ "$posN" -gt -1 ]] || [[ "$posR" -gt -1 ]]; do
            if [[ "$posN" -gt -1 ]]; then
                fragment="${content:0:$posN + 1}";
                content=${content:$posN + 1};
            else
                fragment="${content:0:$posR + 1}";
                content=${content:$posR + 1};
            fi;
            moTrimChars trimmed "$fragment" false true " " '	' '
' '';
            if [ ! -z "$trimmed" ]; then
                fragment="$2$fragment";
            fi;
            result="$result$fragment";
            moFindString posN "$content" '
';
            moFindString posR "$content" '';
        done;
        moTrimChars trimmed "$content" false true " " '	';
        if [ ! -z "$trimmed" ]; then
            content="$2$content";
        fi;
        result="$result$content";
        local "$1" && moIndirect "$1" "$result"
    };
    function moIndirect () 
    { 
        unset -v "$1";
        printf -v "$1" '%s' "$2"
    };
    function moIndirectArray () 
    { 
        unset -v "$1";
        eval $1=\(\"\${@:2}\"\)
    };
    function moIsArray () 
    { 
        local moTestResult;
        moTestResult=$(declare -p "$1" 2>/dev/null) || return 1;
        [[ "${moTestResult:0:10}" == "declare -a" ]] && return 0;
        [[ "${moTestResult:0:10}" == "declare -A" ]] && return 0;
        return 1
    };
    function moIsFunction () 
    { 
        local functionList functionName;
        functionList=$(declare -F);
        functionList=(${functionList//declare -f /});
        for functionName in "${functionList[@]}";
        do
            if [[ "$functionName" == "$1" ]]; then
                return 0;
            fi;
        done;
        return 1
    };
    function moIsStandalone () 
    { 
        local afterTrimmed beforeTrimmed char;
        moTrimChars beforeTrimmed "$2" false true " " '	';
        moTrimChars afterTrimmed "$3" true false " " '	';
        char=$((${#beforeTrimmed} - 1));
        char=${beforeTrimmed:$char};
        if [[ "$char" != '
' ]] && [[ "$char" != '' ]]; then
            if [[ ! -z "$char" ]] || ! $4; then
                return 1;
            fi;
        fi;
        char=${afterTrimmed:0:1};
        if [[ "$char" != '
' ]] && [[ "$char" != '' ]] && [[ ! -z "$char" ]]; then
            return 2;
        fi;
        if [[ "$char" == '' ]] && [[ "${afterTrimmed:1:1}" == '
' ]]; then
            char="$char"'
';
        fi;
        local "$1" && moIndirect "$1" "$((${#beforeTrimmed})) $((${#3} + ${#char} - ${#afterTrimmed}))"
    };
    function moJoin () 
    { 
        local joiner part result target;
        target=$1;
        joiner=$2;
        result=$3;
        shift 3;
        for part in "$@";
        do
            result="$result$joiner$part";
        done;
        local "$target" && moIndirect "$target" "$result"
    };
    function moLoadFile () 
    { 
        local content len;
        content=$(cat $2; echo '.');
        len=$((${#content} - 1));
        content=${content:0:$len};
        local "$1" && moIndirect "$1" "$content"
    };
    function moLoop () 
    { 
        local content context contextBase;
        content=$1;
        contextBase=$2;
        shift 2;
        while [[ "${#@}" -gt 0 ]]; do
            moFullTagName context "$contextBase" "$1";
            moParse "$content" "$context" false;
            shift;
        done
    };
    function moParse () 
    { 
        local moBlock moContent moCurrent moIsBeginning moTag;
        moCurrent=$2;
        moIsBeginning=$3;
        moSplit moContent "$1" '{{' '}}';
        while [[ "${#moContent[@]}" -gt 1 ]]; do
            moTrimWhitespace moTag "${moContent[1]}";
            case $moTag in 
                '#'*)
                    moStandaloneAllowed moContent "${moContent[@]}" $moIsBeginning;
                    moTrimWhitespace moTag "${moTag:1}";
                    moFindEndTag moBlock "$moContent" "$moTag";
                    moFullTagName moTag "$moCurrent" "$moTag";
                    if moTest "$moTag"; then
                        if moIsFunction "$moTag"; then
                            moContent=$($moTag "${moBlock[0]}");
                            moParse "$moContent" "$moCurrent" false;
                            moContent="${moBlock[2]}";
                        else
                            if moIsArray "$moTag"; then
                                eval 'moLoop "${moBlock[0]}" "$moTag" "${!'"$moTag"'[@]}"';
                            else
                                moParse "${moBlock[0]}" "$moCurrent" false;
                            fi;
                        fi;
                    fi;
                    moContent="${moBlock[2]}"
                ;;
                '>'*)
                    moPartial moContent "${moContent[@]}" $moIsBeginning "$moCurrent"
                ;;
                '/'*)
                    moStandaloneAllowed moContent "${moContent[@]}" $moIsBeginning
                ;;
                '^'*)
                    moStandaloneAllowed moContent "${moContent[@]}" $moIsBeginning;
                    moTrimWhitespace moTag "${moTag:1}";
                    moFindEndTag moBlock "$moContent" "$moTag";
                    moFullTagName moTag "$moCurrent" "$moTag";
                    if ! moTest "$moTag"; then
                        moParse "${moBlock[0]}" "$moCurrent" false "$moCurrent";
                    fi;
                    moContent="${moBlock[2]}"
                ;;
                '!'*)
                    moStandaloneAllowed moContent "${moContent[@]}" $moIsBeginning
                ;;
                .)
                    moStandaloneDenied moContent "${moContent[@]}";
                    moShow "$moCurrent" "$moCurrent"
                ;;
                '=')
                    moStandaloneAllowed moContent "${moContent[@]}" $moIsBeginning
                ;;
                '{'*)
                    moStandaloneDenied moContent "${moContent[@]}";
                    moContent="${moTag:1}"'}}'"$moContent";
                    moSplit moContent "$moContent" '}}}';
                    moTrimWhitespace moTag "${moContent[0]}";
                    moFullTagName moTag "$moCurrent" "$moTag";
                    moContent=${moContent[1]};
                    moShow "$moTag" "$moCurrent"
                ;;
                '&'*)
                    moStandaloneDenied moContent "${moContent[@]}";
                    moTrimWhitespace moTag "${moTag:1}";
                    moFullTagName moTag "$moCurrent" "$moTag";
                    moShow "$moTag" "$moCurrent"
                ;;
                *)
                    moStandaloneDenied moContent "${moContent[@]}";
                    moFullTagName moTag "$moCurrent" "$moTag";
                    moShow "$moTag" "$moCurrent"
                ;;
            esac;
            moIsBeginning=false;
            moSplit moContent "$moContent" '{{' '}}';
        done;
        echo -n "${moContent[0]}"
    };
    function moPartial () 
    { 
        local moContent moFilename moIndent moPartial moStandalone;
        if moIsStandalone moStandalone "$2" "$4" $5; then
            moStandalone=($moStandalone);
            echo -n "${2:0:${moStandalone[0]}}";
            moIndent=${2:${moStandalone[0]}};
            moContent=${4:${moStandalone[1]}};
        else
            moIndent="";
            echo -n "$2";
            moContent=$4;
        fi;
        moTrimWhitespace moFilename "${3:1}";
        ( cd "$(dirname "$moFilename")";
        moIndentLines moPartial "$moIndent" "$(
            moLoadFile moPartial "${moFilename##*/}"

            # Fix bash handling of subshells
            # The extra dot is removed in moIndentLines
            echo -n "${moPartial}."
        )";
        moParse "$moPartial" "$6" true );
        local "$1" && moIndirect "$1" "$moContent"
    };
    function moShow () 
    { 
        local moJoined moNameParts;
        if moIsFunction "$1"; then
            CONTENT=$($1 "");
            moParse "$CONTENT" "$2" false;
            return 0;
        fi;
        moSplit moNameParts "$1" ".";
        if [[ -z "${moNameParts[1]}" ]]; then
            if moIsArray "$1"; then
                eval moJoin moJoined "," "\${$1[@]}";
                echo -n "$moJoined";
            else
                echo -n "${!1}";
            fi;
        else
            eval 'echo -n "${'"${moNameParts[0]}"'['"${moNameParts[1]%%.*}"']}"';
        fi
    };
    function moSplit () 
    { 
        local pos result;
        result=("$2");
        moFindString pos "${result[0]}" "$3";
        if [[ "$pos" -ne -1 ]]; then
            result[1]=${result[0]:$pos + ${#3}};
            result[0]=${result[0]:0:$pos};
            if [[ ! -z "$4" ]]; then
                moFindString pos "${result[1]}" "$4";
                if [[ "$pos" -ne -1 ]]; then
                    result[2]="${result[1]:$pos + ${#4}}";
                    result[1]="${result[1]:0:$pos}";
                fi;
            fi;
        fi;
        local "$1" && moIndirectArray "$1" "${result[@]}"
    };
    function moStandaloneAllowed () 
    { 
        local bytes;
        if moIsStandalone bytes "$2" "$4" $5; then
            bytes=($bytes);
            echo -n "${2:0:${bytes[0]}}";
            local "$1" && moIndirect "$1" "${4:${bytes[1]}}";
        else
            echo -n "$2";
            local "$1" && moIndirect "$1" "$4";
        fi
    };
    function moStandaloneDenied () 
    { 
        echo -n "$2";
        local "$1" && moIndirect "$1" "$4"
    };
    function moTest () 
    { 
        moIsFunction "$1" && return 0;
        if moIsArray "$1"; then
            eval '[[ "${#'"$1"'[@]}" -gt 0 ]]' && return 0;
        else
            [[ ! -z "${!1}" ]] && return 0;
        fi;
        return 1
    };
    function moTrimChars () 
    { 
        local back current front last target varName;
        target=$1;
        current=$2;
        front=$3;
        back=$4;
        last="";
        shift 4;
        while [[ "$current" != "$last" ]]; do
            last=$current;
            for varName in "$@";
            do
                $front && current="${current/#$varName}";
                $back && current="${current/%$varName}";
            done;
        done;
        local "$target" && moIndirect "$target" "$current"
    };
    function moTrimWhitespace () 
    { 
        local result;
        moTrimChars result "$2" true true '' '
' '	' " ";
        local "$1" && moIndirect "$1" "$result"
    };
    function moUsage () 
    { 
        grep '^#/' "$1" | cut -c 4-
    }
}
vendor.init () 
{ 
    function vendor.__init () 
    { 
        import.useModule 'vendor_base'
    };
    function vendor.wrap () 
    { 
        vendor_base.wrap "$@"
    };
    function vendor.getPath () 
    { 
        vendor_base.getPath "$@"
    }
}
vendor.wrap () 
{ 
    vendor_base.wrap "$@"
}
vendor_base.getPath () 
{ 
    local __return_path=$1;
    local __file_path="$2";
    local __test_path;
    local __vendor_path_var;
    for __vendor_path_var in "${__import_PATHS[@]}";
    do
        __test_path="${__vendor_path_var}/vendor/${__file_path}";
        if [ -f "$__test_path" ]; then
            string.return_value "$__test_path" $__return_path;
            break;
        fi;
    done
}
vendor_base.init () 
{ 
    function vendor_base.wrap () 
    { 
        local __file_path="$1";
        local __wrap_function="$2";
        local __test_path;
        local __vendor_path_var;
        local __wrapped_function;
        for __vendor_path_var in "${__import_PATHS[@]}";
        do
            __test_path="${__vendor_path_var}/vendor/${__file_path}";
            if [ -f "$__test_path" ]; then
                __wrapped_function="${__wrap_function}() {\n$(cat ${__test_path})\n}";
                eval "$(echo -e "${__wrapped_function}")";
                break;
            fi;
        done
    };
    function vendor_base.getPath () 
    { 
        local __return_path=$1;
        local __file_path="$2";
        local __test_path;
        local __vendor_path_var;
        for __vendor_path_var in "${__import_PATHS[@]}";
        do
            __test_path="${__vendor_path_var}/vendor/${__file_path}";
            if [ -f "$__test_path" ]; then
                string.return_value "$__test_path" $__return_path;
                break;
            fi;
        done
    }
}
vendor_base.wrap () 
{ 
    local __file_path="$1";
    local __wrap_function="$2";
    local __test_path;
    local __vendor_path_var;
    local __wrapped_function;
    for __vendor_path_var in "${__import_PATHS[@]}";
    do
        __test_path="${__vendor_path_var}/vendor/${__file_path}";
        if [ -f "$__test_path" ]; then
            __wrapped_function="${__wrap_function}() {\n$(cat ${__test_path})\n}";
            eval "$(echo -e "${__wrapped_function}")";
            break;
        fi;
    done
}
declare -a __import_DEPENDENCIES=([0]="string" [1]="vendor>base" [2]="vendor" [3]="resource" [4]="build.transpiler" [5]="params>base" [6]="params" [7]="chars" [8]="mustache" [9]="provision" [10]="provision.figlet" [11]="provision.visual.graphviz" [12]="provision.visual.graphviz.graph_easy" [13]="bml.shell" [14]="bml.markdown" [15]="bml" [16]="logger.handlers.formatted" [17]="logger" [18]="parameters" [19]="docs.help" [20]="env")
declare -A -g __import_INITED

import.initModule() {
    local __import_modName="$1"
    "${__import_modName}.init"
    if import.functionExists "${__import_modName}.__init"; then
        "${__import_modName}.__init"
    fi
    __import_INITED["${__import_modName}"]='1'
}
import.useModule() {
    local __import_modName="$1"
    if [[ ! ${__import_INITED["${__import_modName}"]+exists} ]]; then
        import.initModule "$__import_modName"
    else
        "${__import_modName}.init"
    fi
}
import.useModules() {
    local moduleName
    for moduleName in "${__import_DEPENDENCIES[@]}"
    do
        # Replace > with underscore to access namespace
        import.useModule "${moduleName//>/_}"
    done
}
import.functionExists() {
    declare -f -F $1 > /dev/null
    return $?
}


cmd.run.loadArgs() {
    logger.args
    # Load main function args for the module if they exist
    if import.functionExists "${globals[commandNamespace]}.main::args"; then
        "${globals[commandNamespace]}.main::args"
    fi
    local -A params
    local -a unknown
    parameters.load --namespace 'global' --ignore-unknown true --args "$@"
    declare -A -g globals
    for paramValKey in "${!params[@]}"; do
        globals["${paramValKey}"]="${params[${paramValKey}]}"
    done
    logger.processStartupArgs
    "${globals[commandNamespace]}.main" "${unknown[@]}"
}
import.useModules
globals[built]=true
globals[commandNamespace]='env'
globals[commandName]='bf3_env'
globals[buildDate]='2019-11-05 11:45:56'
cmd.run.loadArgs "$@"
